<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高级node-npm发包指令</title>
    <url>/2020/11/09/%E9%AB%98%E7%BA%A7node-npm%E5%8F%91%E5%8C%85%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol>
<li>npm地址必须是官网的，更改地址：<strong>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org</a></strong></li>
<li>初始化仓库： <strong>npm init</strong></li>
<li>登录：<strong>npm login</strong></li>
</ol>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ol>
<li>发布：<strong>npm publish</strong></li>
</ol>
<h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><ol>
<li>修改版本号 <strong>version</strong>字段</li>
<li>再次发布： <strong>npm publish</strong></li>
</ol>
<h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><ol>
<li>删除： <strong>npm unpublish 包名 –force</strong></li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>注册时：<ol>
<li>密码不能太简单，不能与用户名相同</li>
<li>激活邮箱</li>
</ol>
</li>
<li>发布时：<ol>
<li>登录不成功</li>
<li>包名不能重复</li>
<li>重复发包要修改版本号</li>
<li>删除的包24小时内不能重复发布</li>
</ol>
</li>
</ol>
<h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><ol>
<li><strong>package name:</strong> (day01) 不要使用day01 重名率太高</li>
<li><strong>version:</strong> (1.0.0)默认，小更新修改bug在最后+1，更新功能在中间+1，大变动在第一个+1</li>
<li><strong>description:</strong> 描述文件</li>
<li><strong>entry point:</strong> (idnex.js) 出口文件</li>
<li><strong>test command:</strong> 测试代码</li>
<li><strong>git repository:</strong> git 仓库命令</li>
<li><strong>keywords:</strong> 关键词</li>
<li><strong>author:</strong> 创建人</li>
<li><strong>license:</strong> (ISC) 默认</li>
<li><strong>Is this OK?</strong> (yes) yes</li>
</ol>
]]></content>
      <tags>
        <tag>npm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Cherry-Markdown在vue中使用</title>
    <url>/2022/01/05/Cherry-markdown/Cherry-Markdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="Cherry-Markdown-Editor"><a href="#Cherry-Markdown-Editor" class="headerlink" title="Cherry Markdown Editor"></a>Cherry Markdown Editor</h1><hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr>
<p>Cherry Markdown Editor 是一款 Javascript Markdown 编辑器，具有开箱即用、轻量简洁、易于扩展等特点. 它可以运行在浏览器或服务端(NodeJs)。</p>
<p>开发者可以使用非常简单的方式调用并实例化Cherry Markdown编辑器，实例化的编辑器默认支持大部分常用的markdown语法（如标题、目录、流程图、公式等）。</p>
<p>当 Cherry Markdown 编辑器支持的语法不满足开发者需求时，可以快速的进行二次开发或功能扩展。同时，CherryMarkdown编辑器应该由纯JavaScript实现，不应该依赖angular、vue、react等框架技术，框架只提供容器环境即可。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<p>通过 yarn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add cherry-markdown</span><br></pre></td></tr></table></figure>
<p>通过 npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install cherry-markdown --save</span><br></pre></td></tr></table></figure>

<h2 id="Quick-start"><a href="#Quick-start" class="headerlink" title="Quick start"></a>Quick start</h2><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;markdown1&quot; ref=&quot;markdown1&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cherry from &#x27;cherry-markdown&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Cherry&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      editor: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // Cherry实例化要在dom元素挂载完成后进行，此时Cherry实例会在 div#maekdown1 内展示</span><br><span class="line">    this.init()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">      this.cherryInstance = new Cherry(&#123;</span><br><span class="line">        id: &#x27;markdown1&#x27;,</span><br><span class="line">        value: &#x27;# welcome to cherry editor!&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="" alt="cherry-markdown" loading="lazy"></p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span> = <span class="keyword">new</span> <span class="title class_">Cherry</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;markdown1&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;# welcome to cherry editor!&#x27;</span>,</span><br><span class="line">  <span class="attr">editor</span>: &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toolbars</span>: &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">    <span class="attr">toolbar</span>: [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;underline&#x27;</span>, <span class="string">&#x27;strikethrough&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;header&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, &#123; <span class="attr">insert</span>: [<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;link&#x27;</span>, <span class="string">&#x27;br&#x27;</span>, <span class="string">&#x27;formula&#x27;</span>, <span class="string">&#x27;toc&#x27;</span>, <span class="string">&#x27;table&#x27;</span>, <span class="string">&#x27;line-table&#x27;</span>, <span class="string">&#x27;bar-table&#x27;</span>, <span class="string">&#x27;word&#x27;</span>] &#125;, <span class="string">&#x27;settings&#x27;</span>],</span><br><span class="line">    <span class="attr">bubble</span>: [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;underline&#x27;</span>, <span class="string">&#x27;strikethrough&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;sup&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;color&#x27;</span>],</span><br><span class="line">    <span class="attr">float</span>: [<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;h2&#x27;</span>, <span class="string">&#x27;h3&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;checklist&#x27;</span>, <span class="string">&#x27;quote&#x27;</span>, <span class="string">&#x27;quickTable&#x27;</span>, <span class="string">&#x27;code&#x27;</span>],</span><br><span class="line">    <span class="attr">customMenu</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">engine</span>: &#123;</span><br><span class="line">    <span class="attr">syntax</span>: &#123;</span><br><span class="line">      <span class="attr">table</span>: &#123;</span><br><span class="line">        <span class="attr">enableChart</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">externals</span>: [ <span class="string">&#x27;echarts&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">customSyntax</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">externals</span>: &#123;&#125;,</span><br><span class="line">  <span class="title function_">fileUpload</span>(<span class="params">file, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// api.post(file).then(url =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   callback(url)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="">详细配置</a></p>
<h2 id="使用多个"><a href="#使用多个" class="headerlink" title="使用多个"></a>使用多个</h2><p>在一个页面上要调用多个 cherry-markdown 组件时，可以通过props设置 cherry-markdown 的id，根据id进行显示，并设置ref来获取相对应的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;CherryMarkdown v-model=&quot;value1&quot; :editor-type=&quot;&#x27;markdown1&#x27;&quot; ref=&quot;headerChild1&quot; /&gt;</span><br><span class="line">  &lt;CherryMarkdown v-model=&quot;value2&quot; :editor-type=&quot;&#x27;markdown2&#x27;&quot; ref=&quot;headerChild2&quot; /&gt;</span><br><span class="line">  &lt;CherryMarkdown v-model=&quot;value3&quot; :editor-type=&quot;&#x27;markdown3&#x27;&quot; ref=&quot;headerChild3&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;handleClick&quot;&gt;确定&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      console.log(this.$refs.headerChild1.editor.getMarkdown()) // 这里的 editor 是 cherry-markdown 中定义的变量</span><br><span class="line">      console.log(this.$refs.headerChild2.editor.getMarkdown())</span><br><span class="line">      console.log(this.$refs.headerChild3.editor.getMarkdown())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Cherry-Markdown 页面 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :id=&quot;editorType&quot; :ref=&quot;editorType&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cherry from &#x27;cherry-markdown&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Cherry&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    editorType: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      str: &#x27;&#x27;,</span><br><span class="line">      default: &#x27;markdown1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      editor: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.init()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">      this.editor = new Cherry(&#123;</span><br><span class="line">        id: this.editorType,</span><br><span class="line">        value: this.value,</span><br><span class="line">        editor: &#123; theme: &#x27;default&#x27;, height: &#x27;400px&#x27; &#125;,</span><br><span class="line">        toolbars: &#123;</span><br><span class="line">          theme: &#x27;light&#x27;,</span><br><span class="line">          toolbar: [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strikethrough&#x27;, &#x27;|&#x27;, &#x27;color&#x27;, &#x27;header&#x27;, &#x27;|&#x27;, &#x27;list&#x27;, &#123; insert: [&#x27;image&#x27;, &#x27;link&#x27;, &#x27;hr&#x27;, &#x27;br&#x27;, &#x27;code&#x27;, &#x27;formula&#x27;, &#x27;toc&#x27;, &#x27;table&#x27;, &#x27;line-table&#x27;, &#x27;bar-table&#x27;, &#x27;word&#x27;] &#125;, &#x27;settings&#x27;],</span><br><span class="line">          bubble: [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strikethrough&#x27;, &#x27;sub&#x27;, &#x27;sup&#x27;, &#x27;|&#x27;, &#x27;size&#x27;, &#x27;color&#x27;],</span><br><span class="line">          float: [&#x27;h1&#x27;, &#x27;h2&#x27;, &#x27;h3&#x27;, &#x27;|&#x27;, &#x27;checklist&#x27;, &#x27;quote&#x27;, &#x27;quickTable&#x27;, &#x27;code&#x27;],</span><br><span class="line">          customMenu: []</span><br><span class="line">        &#125;,</span><br><span class="line">        engine: &#123;</span><br><span class="line">          syntax: &#123;</span><br><span class="line">            list: &#123;</span><br><span class="line">              listNested: true</span><br><span class="line">            &#125;,</span><br><span class="line">            table: &#123;</span><br><span class="line">              enableChart: false,</span><br><span class="line">              externals: [&#x27;echarts&#x27;]</span><br><span class="line">            &#125;,</span><br><span class="line">            codeBlock: &#123;</span><br><span class="line">              customRenderer: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          customSyntax: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        externals: &#123;&#125;,</span><br><span class="line">        fileUpload(file, callback) &#123;&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      this.editor.setMarkdown(this.editor.engine.makeMarkdown(this.value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
        <category>Cherry-Markdown</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>不以by小经验</tag>
        <tag>cherry-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Cherry-Markdown api</title>
    <url>/2022/01/06/Cherry-markdown/api/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="Cherry-API"><a href="#Cherry-API" class="headerlink" title="Cherry API"></a>Cherry API</h1><hr>
<h2 id="serMarkdown-val-string"><a href="#serMarkdown-val-string" class="headerlink" title="serMarkdown(val:string)"></a>serMarkdown(val:string)</h2><hr>
<p>设置内容。cherry-markdown除了在初始化时绑定value设置内容，还可以通过 <code>serMarkdown()</code> 设置内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">serMarkdown</span>(<span class="string">&#x27;设置内容&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="insert-content-string"><a href="#insert-content-string" class="headerlink" title="insert(content:string)"></a>insert(content:string)</h2><hr>
<p>在光标处或者指定行+偏移量插入内容</p>
<blockquote>
<p>insert(<code>content</code>, <code>isSelect</code>, <code>anchor</code>, <code>focus</code>)</p>
</blockquote>
<ul>
<li><code>content</code> 被插入的文本</li>
<li><code>isSelect</code> 是否选中刚插入的内容，默认 false，不选中</li>
<li><code>anchor</code> [x, y] 代表 x + 1 行，y + 1 字符偏移量，默认 false 会从光标处插入</li>
<li><code>focus</code> 保持编辑器处于 focus 状态，默认 true，选中编辑器（用户可以继续输入）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">insert</span>(<span class="string">&quot;在光标处插入内容&quot;</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">insert</span>(<span class="string">&quot;在第二行插入内容，并选中插入的内容&quot;</span>, <span class="literal">true</span>, [<span class="number">1</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="getMarkdown"><a href="#getMarkdown" class="headerlink" title="getMarkdown()"></a>getMarkdown()</h2><hr>
<p>获取markdown内容。cherry-markdown无法使用 watch 监听 value 变化，可以通过 <code>getMarkdown()</code> 来获取value值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">getMarkdown</span>()</span><br></pre></td></tr></table></figure>

<h2 id="getHtml"><a href="#getHtml" class="headerlink" title="getHtml()"></a>getHtml()</h2><hr>
<p>获取渲染后的html内容。返回值为html字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">getHtml</span>()</span><br></pre></td></tr></table></figure>

<h2 id="export-type-string"><a href="#export-type-string" class="headerlink" title="export(type:string)"></a>export(type:string)</h2><hr>
<p>导出预览区域的内容，<code>type：&#123;&#39;pdf&#39;|&#39;img&#39;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出pdf格式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">export</span>()</span><br><span class="line"><span class="comment">// 导出长图格式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">export</span>(<span class="string">&#x27;img&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="switchModel-model-string"><a href="#switchModel-model-string" class="headerlink" title="switchModel(model:string)"></a>switchModel(model:string)</h2><hr>
<p>切换模式：<code>&#123;&#39;edit&amp;preview&#39;|&#39;editOnly&#39;|&#39;previewOnly&#39;&#125;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双栏编辑模式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">switchModel</span>(<span class="string">&#x27;edit&amp;preview&#x27;</span>)</span><br><span class="line"><span class="comment">// 纯编辑模式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">switchModel</span>(<span class="string">&#x27;editOnly&#x27;</span>)</span><br><span class="line"><span class="comment">// 只读模式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">switchModel</span>(<span class="string">&#x27;previewOnly&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="getToc"><a href="#getToc" class="headerlink" title="getToc()"></a>getToc()</h2><hr>
<p>获取由标题组成的目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">getToc</span>()</span><br></pre></td></tr></table></figure>

<h2 id="getCodeMirror"><a href="#getCodeMirror" class="headerlink" title="getCodeMirror()"></a>getCodeMirror()</h2><hr>
<p>获取左侧编辑器实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">getCodeMirror</span>()</span><br></pre></td></tr></table></figure>

<h2 id="getPreviewer"><a href="#getPreviewer" class="headerlink" title="getPreviewer()"></a>getPreviewer()</h2><hr>
<p>获取右侧预览区对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="title function_">getPreviewer</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Cherry-engine-API"><a href="#Cherry-engine-API" class="headerlink" title="Cherry.engine API"></a>Cherry.engine API</h1><hr>
<h2 id="engine-makeHtml-markdown-string"><a href="#engine-makeHtml-markdown-string" class="headerlink" title="engine.makeHtml(markdown:string)"></a>engine.makeHtml(markdown:string)</h2><hr>
<p>将markdown字符串渲染成Html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">engine</span>.<span class="title function_">makeHtml</span>(<span class="string">&#x27;This is `inline code`&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="engine-makeMarkdown-html-string"><a href="#engine-makeMarkdown-html-string" class="headerlink" title="engine.makeMarkdown(html:string)"></a>engine.makeMarkdown(html:string)</h2><hr>
<p>将html字符串渲染成markdown</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">`&lt;p&gt;This is &lt;code&gt;inline code&lt;/code&gt;&lt;/p&gt;`</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">engine</span>.<span class="title function_">makeMarkdown</span>(html)</span><br></pre></td></tr></table></figure>

<h1 id="Cherry-toolbar-toolbarHandlers-API"><a href="#Cherry-toolbar-toolbarHandlers-API" class="headerlink" title="Cherry.toolbar.toolbarHandlers API"></a>Cherry.toolbar.toolbarHandlers API</h1><hr>
<h2 id="toolbar-toolbarHandlers-bold"><a href="#toolbar-toolbarHandlers-bold" class="headerlink" title="toolbar.toolbarHandlers.bold()"></a>toolbar.toolbarHandlers.bold()</h2><hr>
<p>向cherry编辑器中插入加粗语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">bold</span>()</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-italic"><a href="#toolbar-toolbarHandlers-italic" class="headerlink" title="toolbar.toolbarHandlers.italic()"></a>toolbar.toolbarHandlers.italic()</h2><hr>
<p>向cherry编辑器中插入斜体语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">italic</span>()</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-header-level-int"><a href="#toolbar-toolbarHandlers-header-level-int" class="headerlink" title="toolbar.toolbarHandlers.header(level:int)"></a>toolbar.toolbarHandlers.header(level:int)</h2><hr>
<p>向cherry编辑器中插入标题语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">header</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">header</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">header</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-strikethrough"><a href="#toolbar-toolbarHandlers-strikethrough" class="headerlink" title="toolbar.toolbarHandlers.strikethrough()"></a>toolbar.toolbarHandlers.strikethrough()</h2><hr>
<p>向cherry编辑器中插入删除线语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">strikethrough</span>()</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-list-type-string"><a href="#toolbar-toolbarHandlers-list-type-string" class="headerlink" title="toolbar.toolbarHandlers.list(type:string)"></a>toolbar.toolbarHandlers.list(type:string)</h2><hr>
<p>向cherry编辑器中插入有序、无序列表或者checklist语法</p>
<table>
<thead>
<tr>
<th align="center">level</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘1’</td>
<td align="center">ol 列表</td>
</tr>
<tr>
<td align="center">‘2’</td>
<td align="center">ul 列表</td>
</tr>
<tr>
<td align="center">‘3’</td>
<td align="center">checklist</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序列表</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">list</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 无序列表</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">list</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">// checklist</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">list</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-insert-type-string"><a href="#toolbar-toolbarHandlers-insert-type-string" class="headerlink" title="toolbar.toolbarHandlers.insert(type:string)"></a>toolbar.toolbarHandlers.insert(type:string)</h2><hr>
<p>向cherry编辑器中插入特定语法</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘hr’</td>
<td align="center">删除线</td>
</tr>
<tr>
<td align="center">‘br’</td>
<td align="center">强制换行</td>
</tr>
<tr>
<td align="center">‘code’</td>
<td align="center">代码块</td>
</tr>
<tr>
<td align="center">‘formula’</td>
<td align="center">行内公式</td>
</tr>
<tr>
<td align="center">‘checklist’</td>
<td align="center">检查项</td>
</tr>
<tr>
<td align="center">‘toc’</td>
<td align="center">目录</td>
</tr>
<tr>
<td align="center">‘link’</td>
<td align="center">超链接</td>
</tr>
<tr>
<td align="center">‘image’</td>
<td align="center">图片</td>
</tr>
<tr>
<td align="center">‘video’</td>
<td align="center">视频</td>
</tr>
<tr>
<td align="center">‘audio’</td>
<td align="center">音频</td>
</tr>
<tr>
<td align="center">‘normal-table’</td>
<td align="center">插入3行5列的表格</td>
</tr>
<tr>
<td align="center">‘normal-table-row*col’</td>
<td align="center">如 <code>normal-table-2*4</code> 插入2行(包含表头是3行)4列的表格</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入 3 * 4 的表格</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">insert</span>(<span class="string">&#x27;normal-table-3*4&#x27;</span>)</span><br><span class="line"><span class="comment">// 插入 checklist</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">insert</span>(<span class="string">&#x27;checklist&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="toolbar-toolbarHandlers-graph-type-string"><a href="#toolbar-toolbarHandlers-graph-type-string" class="headerlink" title="toolbar.toolbarHandlers.graph(type:string)"></a>toolbar.toolbarHandlers.graph(type:string)</h2><hr>
<p>向cherry编辑器中插入画图语法</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘1’</td>
<td align="center">流程图</td>
</tr>
<tr>
<td align="center">‘2’</td>
<td align="center">时序图</td>
</tr>
<tr>
<td align="center">‘3’</td>
<td align="center">状态图</td>
</tr>
<tr>
<td align="center">‘4’</td>
<td align="center">类图</td>
</tr>
<tr>
<td align="center">‘5’</td>
<td align="center">饼图</td>
</tr>
<tr>
<td align="center">‘6’</td>
<td align="center">甘特图</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入流程图</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">graph</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 插入时序图</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">graph</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">// 插入类图</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cherryInstance</span>.<span class="property">toolbar</span>.<span class="property">toolbarHandlers</span>.<span class="title function_">graph</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Cherry-Markdown</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>不以by小经验</tag>
        <tag>cherry-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Cherry-Markdown config</title>
    <url>/2022/01/05/Cherry-markdown/config/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><hr>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>可选值</th>
<th>默认值</th>
<th>必填</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>绑定值(markdown 原文)</td>
<td>string</td>
<td>-</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>editor</td>
<td>编辑器配置</td>
<td>object</td>
<td>见下方</td>
<td>-</td>
<td>否</td>
</tr>
<tr>
<td>toolbars</td>
<td>工具栏配置</td>
<td>object</td>
<td>见下方</td>
<td>-</td>
<td>否</td>
</tr>
<tr>
<td>engine</td>
<td>使用文档链接</td>
<td>object</td>
<td>见下方</td>
<td>-</td>
<td>否</td>
</tr>
<tr>
<td>fileUpload</td>
<td>静态资源上传配置</td>
<td>function</td>
<td>见下方</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>externals</td>
<td>引入第三方组件配置</td>
<td>object</td>
<td>见下方</td>
<td>-</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="编辑器配置"><a href="#编辑器配置" class="headerlink" title="编辑器配置"></a>编辑器配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">editor</span>: &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">defaultModel</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Key: <code>theme</code></li>
<li>Description: 用于配置编辑区域的主题</li>
<li>Type: <code>String</code></li>
<li>Default: <code>default</code></li>
<li>Options: <a href="https://codemirror.net/demo/theme.html">参考CodeMirror主题配置</a></li>
</ul>
<hr>
<ul>
<li>Key: <code>height</code></li>
<li>Description: 用于配置编辑区域的高度，当挂载点存在内联设置的 height 样式时，以内联样式为主</li>
<li>Type: <code>String</code></li>
<li>Default: <code>100%</code></li>
</ul>
<hr>
<ul>
<li>Key: <code>defaultModel</code></li>
<li>Description: 用于配置编辑器的初始编辑模式</li>
<li>Type: <code>String</code></li>
<li>Default: <code>&#39;edit&amp;preview&#39;</code></li>
<li>Options:<ul>
<li><code>editOnly</code>: 纯编辑模式（没有预览，可通过toolbar切换成双栏或预览模式）</li>
<li><code>edit&amp;preview</code>: 双栏编辑预览模式</li>
<li><code>previewOnly</code>: 预览模式（没有编辑框，toolbar只显示“返回编辑”按钮，可通过toolbar切换成编辑模式）</li>
</ul>
</li>
</ul>
<h2 id="工具栏配置"><a href="#工具栏配置" class="headerlink" title="工具栏配置"></a>工具栏配置</h2><p>Cherry Markdown Editor 包含三种可配置的工具栏，包括 toolbar(上方固定工具栏)、bubble(选中文本弹出工具栏)与 float(创建新行弹出工具栏)，在其中自定义增加需要的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">toolbars</span>: &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="string">&#x27;dark&#x27;</span>, <span class="comment">// light or dark</span></span><br><span class="line">  toolbar : [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;strikethrough&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;header&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;graph&#x27;</span>,<span class="string">&#x27;togglePreview&#x27;</span>],</span><br><span class="line">  bubble : [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;strikethrough&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;sup&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], <span class="comment">// array or false</span></span><br><span class="line">  float : [<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;h2&#x27;</span>, <span class="string">&#x27;h3&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;checklist&#x27;</span>, <span class="string">&#x27;quote&#x27;</span>, <span class="string">&#x27;quickTable&#x27;</span>, <span class="string">&#x27;code&#x27;</span>], <span class="comment">// array or false</span></span><br><span class="line">  <span class="attr">customMenu</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Key: <code>theme</code></li>
<li>Description: 用于配置编辑区域的主题</li>
<li>Type: <code>String</code></li>
<li>Default: <code>&#39;dark&#39;</code></li>
<li>Options:<ul>
<li><code>light</code>: 亮色主题</li>
<li><code>dark</code>: 暗色主题</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Key: <code>toolbar</code></li>
<li>Description: 用于配置顶部工具栏及菜单按钮顺序</li>
<li>Type: <code>Array&lt;string | &#123; insert: Array&lt;string&gt; &#125;&gt; | false</code></li>
<li>Default: <code>[&#39;bold&#39;, &#39;italic&#39;, &#39;strikethrough&#39;, &#39;|&#39;, &#39;color&#39;, &#39;header&#39;, &#39;|&#39;, &#39;list&#39;, &#123; insert: [ &#39;image&#39;, &#39;audio&#39;, &#39;video&#39;, &#39;link&#39;, &#39;hr&#39;, &#39;br&#39;, &#39;code&#39;, &#39;formula&#39;, &#39;toc&#39;, &#39;table&#39;, &#39;line-table&#39;, &#39;bar-table&#39;, &#39;pdf&#39;, &#39;word&#39;, ], &#125;, &#39;graph&#39;, &#39;settings&#39;]</code></li>
<li>Options:<ul>
<li><code>false</code>: 传入 false 时关闭顶部菜单 (v4.0.11及以前版本不支持)</li>
<li><code>string[]</code>: 菜单名称的集合，渲染的菜单按钮顺序跟随数组的元素顺序</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Key: <code>bubble</code></li>
<li>Description: 用于配置选中后的悬浮菜单</li>
<li>Type: <code>Array&lt;string | &#123; insert: Array&lt;string&gt; &#125;&gt; | false</code></li>
<li>Default: <code>[&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strikethrough&#39;, &#39;sub&#39;, &#39;sup&#39;, &#39;|&#39;, &#39;size&#39;, &#39;color&#39;]</code></li>
<li>Options:<ul>
<li><code>false</code>: 传入 false 时关闭悬浮菜单</li>
<li><code>string[]</code>: 菜单名称的集合，渲染的菜单按钮顺序跟随数组的元素顺序</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Key: <code>float</code></li>
<li>Description: 用于配置新行的行内菜单</li>
<li>Type: <code>Array&lt;string | &#123; insert: Array&lt;string&gt; &#125;&gt; | false</code></li>
<li>Default: <code>[&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strikethrough&#39;, &#39;sub&#39;, &#39;sup&#39;, &#39;|&#39;, &#39;size&#39;, &#39;color&#39;]</code></li>
<li>Options:<ul>
<li><code>false</code>: 传入 false 时关闭新行行内菜单</li>
<li><code>string[]</code>: 菜单名称的集合，渲染的菜单按钮顺序跟随数组的元素顺序</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Key: <code>customMenu</code></li>
<li>Description: 用于配置编辑区域的主题</li>
<li>Type: <code>Array&lt;string | &#123; insert: Array&lt;string&gt; &#125;&gt; | false</code></li>
<li>Default: <code>&#123;&#125;</code></li>
</ul>
<hr>
<p>内置菜单名称参考</p>
<ul>
<li>Options:<ul>
<li>|: 分隔符</li>
<li>bold: 加粗</li>
<li>italic: 斜体</li>
<li>underline: 下划线</li>
<li>strikethrough: 删除线</li>
<li>sub: 下标</li>
<li>sup: 上标</li>
<li>size: 文字尺寸</li>
<li>color: 文字颜色</li>
<li>header: 标题菜单</li>
<li>h1: 一级标题</li>
<li>h2: 二级标题</li>
<li>h3: 三级标题</li>
<li>checklist: 任务列表</li>
<li>list: 列表菜单</li>
<li>insert: 插入菜单（可定制插入项）</li>
<li>image: 插入图片</li>
<li>audio: 插入音频</li>
<li>video: 插入视频</li>
<li>pdf: 插入pdf</li>
<li>word: 插入word文档</li>
<li>link: 插入链接</li>
<li>hr: 插入水平分割线</li>
<li>br: 插入新行</li>
<li>code: 插入代码块</li>
<li>formula: 插入数学公式</li>
<li>toc: 插入目录</li>
<li>table: 插入表格(gfm)</li>
<li>line-table: 插入带折线图的高级表格(需要引入echarts)</li>
<li>bar-table: 插入带柱状图的高级表格(需要引入echarts)</li>
<li>graph: 画图(需要引入mermaid)</li>
<li>settings: 设置</li>
<li>switchModel: 切换编辑/预览模式(用于单栏编辑/预览模式)</li>
<li>togglePreview: 打开/关闭预览区(用于左右分栏模式)</li>
</ul>
</li>
</ul>
<h2 id="引擎配置"><a href="#引擎配置" class="headerlink" title="引擎配置"></a>引擎配置</h2><p>可通过配置 engine 对象来配置 markdown 的解析规则，比如 table 是否可使用 chart（pro 版本可用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">engine</span>: &#123;</span><br><span class="line">  <span class="comment">// 内置语法配置</span></span><br><span class="line">  <span class="attr">syntax</span>: &#123; <span class="comment">//                                       &lt;[Object]&gt; 语法规则</span></span><br><span class="line">    <span class="comment">// 语法开关</span></span><br><span class="line">    <span class="comment">// &#x27;hookName&#x27;: false,</span></span><br><span class="line">    <span class="comment">// 语法配置</span></span><br><span class="line">    <span class="comment">// &#x27;hookName&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="attr">list</span>: &#123;</span><br><span class="line">        <span class="attr">listNested</span>: <span class="literal">true</span> <span class="comment">// 同级列表类型转换后变为子级</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// pro 版本功能</span></span><br><span class="line">    <span class="attr">table</span>: &#123;</span><br><span class="line">        <span class="attr">enableChart</span>: <span class="literal">true</span>, <span class="comment">//                        &lt;[Boolean]&gt; 激活表格绘制图形</span></span><br><span class="line">        <span class="attr">chartRenderEngine</span>: <span class="title class_">EChartsTableEngine</span>, <span class="comment">//    &lt;[Array]&gt; 绘制图形的依赖</span></span><br><span class="line">        <span class="attr">externals</span>: [ <span class="string">&#x27;echarts&#x27;</span> ] <span class="comment">//                  &lt;[Constructor]&gt; 绘制图形的类，应该包括以下方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">codeBlock</span>: &#123;</span><br><span class="line">      <span class="attr">customRenderer</span>: &#123; <span class="comment">// 自定义语法渲染器</span></span><br><span class="line">        <span class="attr">mermaid</span>: <span class="keyword">new</span> <span class="title class_">MermaidCodeEngine</span>(&#123; mermaidAPI, <span class="attr">theme</span>: <span class="string">&#x27;neutral&#x27;</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义语法</span></span><br><span class="line">  <span class="attr">customSyntax</span>: &#123;</span><br><span class="line">    <span class="comment">// &#x27;SyntaxClass&#x27;: SyntaxClass   &lt;[Object]&gt; 自定义语法规则，同名语法会覆盖编辑器默认的语法</span></span><br><span class="line">    <span class="comment">// 名字冲突时强制覆盖内置语法解析器</span></span><br><span class="line">    <span class="comment">// &#x27;SyntaxClass&#x27;: &#123;             &lt;[String]&gt; hook 名字</span></span><br><span class="line">    <span class="comment">//   syntax: SyntaxClass,       &lt;[SyntaxBase]&gt; hook 构造函数</span></span><br><span class="line">    <span class="comment">//   force: true,               &lt;[Boolean]&gt; 是否强制覆盖同名 hook</span></span><br><span class="line">    <span class="comment">//   before: &#x27;HOOK_NAME&#x27;,       &lt;[String]&gt; hookName，在这个 hook 之前执行</span></span><br><span class="line">    <span class="comment">//   after: &#x27;HOOK_NAME&#x27;         &lt;[String]&gt; hookName，在这个 hook 之后执行</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Key: <code>syntax</code></li>
<li>Description: 编辑器内置语法配置</li>
<li>Type: <code>&#123; [HOOK_NAME: string]: &#123; [option: string]: any &#125; | boolean &#125;</code></li>
<li>Default: <code>&#123;&#125;</code></li>
</ul>
<hr>
<ul>
<li>Key: <code>customSyntax</code></li>
<li>Description: 自定义语法配置</li>
<li>Type: <code>&#123; [HOOK_NAME: string]: &#123; [option: string]: any &#125; | boolean &#125;</code></li>
<li>Default: <code>&#123;&#125;</code></li>
</ul>
<h2 id="拓展配置"><a href="#拓展配置" class="headerlink" title="拓展配置"></a>拓展配置</h2><p>外部依赖配置</p>
<ul>
<li>Type: <code>&#123; [packageName: string]: Object &#125;</code></li>
<li>Default: <code>&#123;&#125;</code></li>
<li>Usage: 从全局对象引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Markdown</span>(&#123;</span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">echarts</span>: <span class="variable language_">window</span>.<span class="property">echarts</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
通过 <code>import</code> 引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Markdown</span>(&#123;</span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    echarts</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态资源上传配置"><a href="#静态资源上传配置" class="headerlink" title="静态资源上传配置"></a>静态资源上传配置</h2><p>Cherry Markdown Editor 不会直接上传图片或是文件，只会通过钩子函数(fileUpload)向上游提供用户所选择的图片、word 文档等，fileUpload 函数接受两个传入参数：</p>
<ol>
<li>file: 用户选择用来上传的文件对象</li>
<li>callback: 当上游处理好静态资源后，应调用 callback 并传入上传好的静态资源路径回显在 markdown 编辑器中。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Cherry</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;markdown&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="title function_">fileUpload</span>(<span class="params">file, callback</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Markdown-constants"><a href="#Markdown-constants" class="headerlink" title="Markdown.constants"></a>Markdown.constants</h2><p>Markdown 编辑器常量</p>
<p><strong>Markdown.constants.HOOKS_TYPE_LIST</strong><br>语法 Hook 类型常量列表</p>
<ul>
<li>Type: <code>enum</code></li>
<li>Value: <code>&#123; DEFAULT: &#39;sentence&#39;, SEN: &#39;sentence&#39;, PAR: &#39;paragraph&#39; &#125;</code></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Cherry-Markdown</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>不以by小经验</tag>
        <tag>cherry-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Echarts时遇到的问题</title>
    <url>/2021/08/30/Echarts/%E4%BD%BF%E7%94%A8Echarts%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="在使用-Echarts-图表时可能会遇到的问题"><a href="#在使用-Echarts-图表时可能会遇到的问题" class="headerlink" title="在使用 Echarts 图表时可能会遇到的问题"></a>在使用 Echarts 图表时可能会遇到的问题</h1><h2 id="数据未重置"><a href="#数据未重置" class="headerlink" title="数据未重置"></a>数据未重置</h2><p>问题描述：</p>
<ol>
<li>我的数据改变了，但我的图表上还有之前的内容</li>
<li>我使用地图组件做了动态攻击线，但每隔一段时间重新请求数据后，动态线出现重影<br>原因：<br>刷新得重新初始化表格，而不只是重新绑定数据，不然之前的最后一条数据会遗留下来<br>解决：</li>
</ol>
<p>查看API，发现通过 myChart.clear() 这个方法可以解决问题，是最简单的。<br>在 myChart.setOption(option) 之前使用这个方法。</p>
<p>相关文档：<br><a href="https://q.cnblogs.com/q/79521/">https://q.cnblogs.com/q/79521/</a></p>
<h2 id="图表宽高问题"><a href="#图表宽高问题" class="headerlink" title="图表宽高问题"></a>图表宽高问题</h2><p>问题描述：<br>当父级盒子宽高设置为100%，图表宽度变成100%<br>也有另一种情况，通过 display 来展示父级盒子是否展示，当父级盒子重新打开之后，图表宽高会变为0<br>原因：<br>Echarts 图表是根据你定义的div 的样式来确定图表的大小，当图表隐藏时，Echarts会找不到div的宽和高，再次显示时它会给自己一个非常小的默认宽高值，所以在隐藏显示后会发现它变得非常非常的小，或者消失</p>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;chart&quot; ref=&quot;chart&quot; class=&quot;chart&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getChartWH() &#123;</span><br><span class="line">      this.chart = this.$echarts.init(document.getElementById(&#x27;chart&#x27;)) // 获取父级盒子</span><br><span class="line">      this.chartWidth = this.$refs[&#x27;chart&#x27;].clientWidth // 通过ref获取宽高</span><br><span class="line">      this.chartHeight = this.$refs[&#x27;chart&#x27;].clientHeight</span><br><span class="line">      window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; // 通过 addEventListener 监听变化</span><br><span class="line">        this.chart.resize() // 当父级盒子宽高变化时，重新渲染图表大小</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果你需要多个图表进行切换，只需要封装一下就可以多次调用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-if=&quot;cur === 0&quot; id=&quot;chart&quot; ref=&quot;chart&quot; class=&quot;chart&quot; /&gt;</span><br><span class="line">  &lt;div v-elseif=&quot;cur === 1&quot; id=&quot;chart1&quot; ref=&quot;chart1&quot; class=&quot;chart&quot; /&gt;</span><br><span class="line">  &lt;div v-elseif=&quot;cur === 2&quot; id=&quot;chart2&quot; ref=&quot;chart2&quot; class=&quot;chart&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getChartWH(chart) &#123;</span><br><span class="line">      this.chartWidth = this.$refs[chart].clientWidth // 通过ref获取宽高</span><br><span class="line">      this.chartHeight = this.$refs[chart].clientHeight</span><br><span class="line">      window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; // 通过 addEventListener 监听变化</span><br><span class="line">        this.chart.resize() // 当父级盒子宽高变化时，重新渲染图表大小</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getData() &#123;</span><br><span class="line">      this.chart = this.$echarts.init(document.getElementById(&#x27;chart&#x27;))</span><br><span class="line">      this.getChartWH(&#x27;chart&#x27;) // 调用方法时将传递的值替换一下就可以了</span><br><span class="line">      this.chart.setOption(this.option)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是调用 <code>getChartWH</code> 方法要在 dom 元素渲染成功后，否则会找不到</p>
]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>el-cascader点击文字选中</title>
    <url>/2021/12/10/ElementUI/EL-Cascader/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="多选模式"><a href="#多选模式" class="headerlink" title="多选模式"></a>多选模式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-cascader</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:options</span>=<span class="string">&quot;options&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:props</span>=<span class="string">&quot;&#123; multiple: true &#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">filterable</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-cascader-panel</span> <span class="selector-class">.el-checkbox</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-cascader-node__label</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个样式针对IE有用，不考虑IE的可以不用管*/</span></span><br><span class="line"><span class="selector-class">.el-cascader-panel</span> <span class="selector-class">.el-cascader-node__postfix</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单选模式"><a href="#单选模式" class="headerlink" title="单选模式"></a>单选模式</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-cascader-panel</span> <span class="selector-class">.el-radio</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.el-cascader-panel</span> <span class="selector-class">.el-radio__input</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.el-cascader-panel</span> <span class="selector-class">.el-cascader-node__postfix</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>ElementUI</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>el-form表单校验</title>
    <url>/2021/12/22/ElementUI/EL-Form/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。校验规则参见 <a href="https://github.com/yiminghe/async-validator">async-validator</a></p>
<h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><p>在data中定义表单验证规则的对象数组rules（可以单独编写验证器函数），并直接绑定到表单标签的rules参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;产品名称&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;name&quot; v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;产品描述&quot; prop=&quot;desc&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;desc&quot; v-model=&quot;ruleForm.desc&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ruleForm: &#123;</span><br><span class="line">          name: &#x27;&#x27;,</span><br><span class="line">          desc: &#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        rules: &#123;</span><br><span class="line">          name: [</span><br><span class="line">            &#123; required: true, message: &#x27;请输入产品名称&quot;&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">            &#123; min: 3, max: 5, message: &#x27;长度在 3 到 5 个字符&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">          ],</span><br><span class="line">          desc: [&#123; required: true, message: &#x27;请填写产品描述&#x27;, trigger: &#x27;blur&#x27; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h1><p>validator是单个表单域格式验证的验证器，一般是需要比较复杂的格式验证的时候才会用。如果是非空验证、数据类型验证或者正则表达式能处理的，都可以直接通过rules的type/Pattern等相关参数直接配置就好了。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.password&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      var validatePass = (rule, value, callback) =&gt; &#123;</span><br><span class="line">        if (value === &#x27;&#x27;) &#123;</span><br><span class="line">          callback(new Error(&#x27;请输入密码&#x27;))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          if (this.ruleForm.checkPass !== &#x27;&#x27;) &#123;</span><br><span class="line">            this.$refs.ruleForm.validateField(&#x27;checkPass&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      var validatePass2 = (rule, value, callback) =&gt; &#123;</span><br><span class="line">        if (value === &#x27;&#x27;) &#123;</span><br><span class="line">          callback(new Error(&#x27;请再次输入密码&#x27;))</span><br><span class="line">        &#125; else if (value !== this.ruleForm.password) &#123;</span><br><span class="line">          callback(new Error(&#x27;两次输入密码不一致!&#x27;))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          callback()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;</span><br><span class="line">        ruleForm: &#123;</span><br><span class="line">          password: &#x27;&#x27;,</span><br><span class="line">          checkPass: &#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        rules: &#123;</span><br><span class="line">          password: [&#123; validator: validatePass, trigger: &#x27;blur&#x27; &#125;],</span><br><span class="line">          checkPass: [&#123; validator: validatePass2, trigger: &#x27;blur&#x27; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="动态表单校验"><a href="#动态表单校验" class="headerlink" title="动态表单校验"></a>动态表单校验</h1><p>对于单个表单域，可以直接对表单域的rules参数进行配置，来实现格式验证，这种方法一般比较适用于格式验证比较简单的情况。如果需要进行验证的字段比较多，或者验证规则比较复杂，那么最好使用对整个表单进行验证的方式。<br>对表单域进行校验时，<code>prop</code> 的内容与 <code>v-model</code> 的内容要一一对应才能校验成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;dynamicValidateForm&quot; ref=&quot;dynamicValidateForm&quot; label-width=&quot;100px&quot; class=&quot;demo-dynamic&quot;&gt;</span><br><span class="line">    &lt;el-form-item </span><br><span class="line">      label=&quot;邮箱&quot;</span><br><span class="line">      prop=&quot;email&quot;</span><br><span class="line">      :rules=&quot;[</span><br><span class="line">        &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">        &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的邮箱地址&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125;</span><br><span class="line">      ]&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-input v-model=&quot;dynamicValidateForm.email&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item</span><br><span class="line">      v-for=&quot;(domain, index) in dynamicValidateForm.domains&quot; :label=&quot;&#x27;域名&#x27; + index&quot; :key=&quot;domain.key&quot; </span><br><span class="line">      :prop=&quot;&#x27;domains.&#x27; + index + &#x27;.value&#x27;&quot; </span><br><span class="line">      :rules=&quot;&#123;</span><br><span class="line">        required: true, message: &#x27;域名不能为空&#x27;, trigger: &#x27;blur&#x27;</span><br><span class="line">      &#125;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        dynamicValidateForm: &#123;</span><br><span class="line">          domains: [&#123;</span><br><span class="line">            value: &#x27;&#x27;</span><br><span class="line">          &#125;],</span><br><span class="line">          email: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>ElementUI</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>饿了么树形控件操作</title>
    <url>/2021/11/24/ElementUI/EL-Tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在使用树形组件时，组件展示规则和分数，并添加以下操作功能</p>
<ol>
<li>添加根节点</li>
<li>修改节点名称</li>
<li>添加子节点</li>
<li>删除节点</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>添加根节点</li>
<li>修改节点名称</li>
<li>添加子节点</li>
<li>删除节点</li>
</ol>
<h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><p>根据需求增加或删除相关内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div v-loading=&quot;isLoading&quot; class=&quot;comp-tree&quot;&gt;</span><br><span class="line">		&lt;el-button class=&quot;comp-tr-top&quot; </span><br><span class="line">			type=&quot;primary&quot; </span><br><span class="line">			size=&quot;small&quot; </span><br><span class="line">			@click=&quot;handleAddTop&quot;&gt;添加顶级节点&lt;/el-button&gt;</span><br><span class="line">		&lt;!-- tree --&gt;</span><br><span class="line">		&lt;el-tree ref=&quot;SlotTree&quot;</span><br><span class="line">			:data=&quot;setTree&quot;</span><br><span class="line">			:props=&quot;defaultProps&quot;</span><br><span class="line">			:expand-on-click-node=&quot;false&quot;</span><br><span class="line">			highlight-current</span><br><span class="line">			:node-key=&quot;NODE_KEY&quot;&gt;</span><br><span class="line">				&lt;div class=&quot;comp-tr-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt;</span><br><span class="line">					&lt;!-- 编辑状态 --&gt;</span><br><span class="line">					&lt;template v-if=&quot;node.isEdit&quot;&gt;</span><br><span class="line">						&lt;el-input v-model=&quot;data.name&quot; </span><br><span class="line">							autofocus</span><br><span class="line">							size=&quot;mini&quot;</span><br><span class="line">							:ref=&quot;&#x27;slotTreeInput&#x27;+data[NODE_KEY]&quot;</span><br><span class="line">							@blur.stop=&quot;handleInput(node, data)&quot;</span><br><span class="line">							@keyup.enter.native=&quot;handleInput(node, data)&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">					&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">					&lt;!-- 非编辑状态 --&gt;</span><br><span class="line">					&lt;template v-else&gt;</span><br><span class="line">						&lt;!-- 名称： 新增节点增加class（is-new） --&gt;</span><br><span class="line">						&lt;span :class=&quot;[data[NODE_KEY] &lt; NODE_ID_START ? &#x27;is-new&#x27; : &#x27;&#x27;, &#x27;comp-tr-node--name&#x27;]&quot;&gt;</span><br><span class="line">							&#123;&#123; node.label &#125;&#125;</span><br><span class="line">						&lt;/span&gt;</span><br><span class="line">						</span><br><span class="line">						&lt;!-- 按钮 --&gt;</span><br><span class="line">						&lt;span class=&quot;comp-tr-node--btns&quot;&gt;</span><br><span class="line">							&lt;!-- 新增 --&gt;</span><br><span class="line">							&lt;el-button icon=&quot;el-icon-plus&quot; </span><br><span class="line">								size=&quot;mini&quot;</span><br><span class="line">								circle </span><br><span class="line">								type=&quot;primary&quot;</span><br><span class="line">								@click=&quot;handleAdd(node, data)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">							&lt;!-- 编辑 --&gt;</span><br><span class="line">							&lt;el-button icon=&quot;el-icon-edit&quot; </span><br><span class="line">								size=&quot;mini&quot;</span><br><span class="line">								circle </span><br><span class="line">								type=&quot;info&quot;</span><br><span class="line">								@click=&quot;handleEdit(node, data)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">							&lt;!-- 删除 --&gt;</span><br><span class="line">							&lt;el-button icon=&quot;el-icon-delete&quot; </span><br><span class="line">								size=&quot;mini&quot;</span><br><span class="line">								circle </span><br><span class="line">								type=&quot;danger&quot;</span><br><span class="line">								@click=&quot;handleDelete(node, data)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">						&lt;/span&gt;</span><br><span class="line">					&lt;/template&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">			&lt;/el-tree&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">	name: &#x27;component-tree&#x27;,</span><br><span class="line">	data()&#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			isLoading: false, // 是否加载</span><br><span class="line">			setTree: [], // tree数据</span><br><span class="line">			NODE_KEY: &#x27;id&#x27;, // id对应字段</span><br><span class="line">			MAX_LEVEL: 3, // 设定最大层级</span><br><span class="line">			NODE_ID_START: 0, // 新增节点id，逐次递减</span><br><span class="line">			startId: null,</span><br><span class="line">			defaultProps: &#123; // 默认设置</span><br><span class="line">				children: &#x27;children&#x27;,</span><br><span class="line">				label: &#x27;name&#x27;</span><br><span class="line">			&#125;,</span><br><span class="line">			initParam: &#123; // 新增参数</span><br><span class="line">				name: &#x27;新增节点&#x27;,</span><br><span class="line">				pid: 0,</span><br><span class="line">				children: []</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	created()&#123;</span><br><span class="line">		// 初始值</span><br><span class="line">		this.startId = this.NODE_ID_START</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		handleDelete(_node, _data) &#123; // 删除节点</span><br><span class="line">			console.log(_node, _data)</span><br><span class="line">			// 判断是否存在子节点</span><br><span class="line">			if(_data.children &amp;&amp; _data.children.length !== 0) &#123;</span><br><span class="line">				this.$message.error(&quot;此节点有子级，不可删除！&quot;)</span><br><span class="line">				return false;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				// 删除操作</span><br><span class="line">				let DeletOprate = () =&gt; &#123;</span><br><span class="line">					this.$nextTick(() =&gt; &#123;</span><br><span class="line">						if(this.$refs.SlotTree)&#123;</span><br><span class="line">							this.$refs.SlotTree.remove(_data)</span><br><span class="line">							this.$message.success(&quot;删除成功！&quot;)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 二次确认</span><br><span class="line">				let ConfirmFun = () =&gt; &#123;</span><br><span class="line">					this.$confirm(&quot;是否删除此节点？&quot;, &quot;提示&quot;, &#123;</span><br><span class="line">						confirmButtonText: &quot;确认&quot;,</span><br><span class="line">						cancelButtonText: &quot;取消&quot;,</span><br><span class="line">						type: &quot;warning&quot;</span><br><span class="line">					&#125;).then(() =&gt; &#123;</span><br><span class="line">						DeletOprate()</span><br><span class="line">					&#125;).catch(() =&gt; &#123;&#125;)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 判断是否新增： 新增节点直接删除，已存在的节点要二次确认</span><br><span class="line">				_data[this.NODE_KEY] &lt; this.NODE_ID_START ? DeletOprate() : ConfirmFun()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		handleInput(_node, _data) &#123; // 修改节点</span><br><span class="line">			console.log(_node, _data)</span><br><span class="line">			// 退出编辑状态</span><br><span class="line">			if(_node.isEdit) &#123;</span><br><span class="line">				this.$set(_node, &#x27;isEdit&#x27;, false)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		handleEdit(_node, _data) &#123; // 编辑节点</span><br><span class="line">			console.log(_node, _data)</span><br><span class="line">			// 设置编辑状态</span><br><span class="line">			if(!_node.isEdit) &#123;</span><br><span class="line">				this.$set(_node, &#x27;isEdit&#x27;, true)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 输入框聚焦</span><br><span class="line">			this.$nextTick(() =&gt; &#123;</span><br><span class="line">				if(this.$refs[&#x27;slotTreeInput&#x27; + _data[this.NODE_KEY]]) &#123;</span><br><span class="line">					this.$refs[&#x27;slotTreeInput&#x27; + _data[this.NODE_KEY]].$refs.input.focus()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		handleAdd(_node, _data) &#123; // 新增节点</span><br><span class="line">			console.log(_node, _data)</span><br><span class="line">			// 判断层级</span><br><span class="line">			if(_node.level &gt;= this.MAX_LEVEL) &#123;</span><br><span class="line">				this.$message.warning(&quot;当前已达到&quot; + this.MAX_LEVEL + &quot;级，无法新增！&quot;)</span><br><span class="line">				return false</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 参数修改</span><br><span class="line">			let obj = JSON.parse(JSON.stringify(this.initParam)) // copy参数</span><br><span class="line">			obj.pid = _data[this.NODE_KEY] // 父id</span><br><span class="line">			obj[this.NODE_KEY] = --this.startId // 节点id：逐次递减id</span><br><span class="line">			// 判断字段是否存在</span><br><span class="line">			if(!_data.children) &#123;</span><br><span class="line">				this.$set(_data, &#x27;children&#x27;, [])</span><br><span class="line">			&#125;</span><br><span class="line">			// 新增数据</span><br><span class="line">			_data.children.push(obj)</span><br><span class="line"></span><br><span class="line">			// 展开节点</span><br><span class="line">			if(!_node.expanded) &#123;</span><br><span class="line">				_node.expanded = true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		handleAddTop() &#123; // 添加顶部节点</span><br><span class="line">			let obj = JSON.parse(JSON.stringify(this.initParam)) // copy参数</span><br><span class="line">			obj[this.NODE_KEY] = --this.startId // 节点id：逐次递减id</span><br><span class="line">			this.setTree.push(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">	/* common */</span><br><span class="line"></span><br><span class="line">	// 显示按钮</span><br><span class="line">	.show-btns&#123;</span><br><span class="line">		opacity: 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* common end */</span><br><span class="line"></span><br><span class="line">	.comp-tree&#123;</span><br><span class="line">		width: 100%;</span><br><span class="line">		max-width: 700px;</span><br><span class="line">		max-height: 80vh;</span><br><span class="line">		padding: 2em;</span><br><span class="line">		overflow: auto;</span><br><span class="line">		// 顶部按钮</span><br><span class="line">		.comp-tr-top&#123;</span><br><span class="line">			width: 100px;</span><br><span class="line">			margin-bottom: 2em;</span><br><span class="line">		&#125;</span><br><span class="line">		// 自定义节点</span><br><span class="line">		.comp-tr-node&#123;</span><br><span class="line">			// label</span><br><span class="line">			.comp-tr-node--name&#123;</span><br><span class="line">				display: inline-block;</span><br><span class="line">				line-height: 40px;</span><br><span class="line">				min-height: 40px;</span><br><span class="line">				// 新增</span><br><span class="line">				&amp;.is-new&#123;</span><br><span class="line">					font-weight: bold;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// button</span><br><span class="line">			.comp-tr-node--btns&#123;</span><br><span class="line">				margin-left: 10px;</span><br><span class="line">				opacity: 0;</span><br><span class="line">				transition: opacity .1s;</span><br><span class="line">				.el-button&#123;</span><br><span class="line">					transform: scale(0.8);// 缩小按钮</span><br><span class="line">					&amp; + .el-button&#123;</span><br><span class="line">						margin-left: -1px;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 高亮显示按钮</span><br><span class="line">		.is-current&#123;</span><br><span class="line">			&amp;&gt;.el-tree-node__content&#123;</span><br><span class="line">				.comp-tr-node--btns&#123;</span><br><span class="line">					@extend .show-btns;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 悬浮显示按钮</span><br><span class="line">		.el-tree-node__content&#123;</span><br><span class="line">			&amp;:hover&#123;</span><br><span class="line">				.comp-tr-node--btns&#123;</span><br><span class="line">					@extend .show-btns;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>相关文档：<a href="https://segmentfault.com/a/1190000011574698#item-8">https://segmentfault.com/a/1190000011574698#item-8</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>ElementUI</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>prop链式写法</title>
    <url>/2021/09/26/ElementUI/prop%E9%93%BE%E5%BC%8F%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;dynamicValidateForm&quot; ref=&quot;dynamicValidateForm&quot; label-width=&quot;100px&quot; class=&quot;demo-dynamic&quot;&gt;</span><br><span class="line">    &lt;el-form-item</span><br><span class="line">      prop=&quot;email&quot;</span><br><span class="line">      label=&quot;邮箱&quot;</span><br><span class="line">      :rules=&quot;[</span><br><span class="line">        &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">        &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的邮箱地址&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125;</span><br><span class="line">      ]&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-input v-model=&quot;dynamicValidateForm.email&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item</span><br><span class="line">      v-for=&quot;(domain, index) in dynamicValidateForm.domains&quot;</span><br><span class="line">      :label=&quot;&#x27;域名&#x27; + index&quot;</span><br><span class="line">      :key=&quot;domain.key&quot;</span><br><span class="line">      :prop=&quot;&#x27;domains.&#x27; + index + &#x27;.value&#x27;&quot;</span><br><span class="line">      :rules=&quot;&#123;</span><br><span class="line">        required: true, message: &#x27;域名不能为空&#x27;, trigger: &#x27;blur&#x27;</span><br><span class="line">      &#125;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-input v-model=&quot;domain.value&quot;&gt;&lt;/el-input&gt;&lt;el-button @click.prevent=&quot;removeDomain(domain)&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;</span><br><span class="line">      &lt;el-button @click=&quot;addDomain&quot;&gt;新增域名&lt;/el-button&gt;</span><br><span class="line">      &lt;el-button @click=&quot;resetForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        dynamicValidateForm: &#123;</span><br><span class="line">          domains: [&#123;</span><br><span class="line">            value: &#x27;&#x27;</span><br><span class="line">          &#125;],</span><br><span class="line">          email: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      submitForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].validate((valid) =&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            alert(&#x27;submit!&#x27;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            console.log(&#x27;error submit!!&#x27;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      resetForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].resetFields();</span><br><span class="line">      &#125;,</span><br><span class="line">      removeDomain(item) &#123;</span><br><span class="line">        var index = this.dynamicValidateForm.domains.indexOf(item)</span><br><span class="line">        if (index !== -1) &#123;</span><br><span class="line">          this.dynamicValidateForm.domains.splice(index, 1)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      addDomain() &#123;</span><br><span class="line">        this.dynamicValidateForm.domains.push(&#123;</span><br><span class="line">          value: &#x27;&#x27;,</span><br><span class="line">          key: Date.now()</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其中动态表单校验中用到了 <code>:prop=&quot;&#39;domains.&#39;+index+&#39;.value&#39;&quot;</code> 而 <code>domains</code> 是一个数组.常规来说这么写相当于是 <code>domains.1.value</code> 的写法，但这种写法肯定是有问题的。没看源码不是很理解这样的链式操作。</p>
<p>感觉 <code>:prop=&quot;&#39;domains.&#39;+index+&#39;.value&#39;&quot;</code> 这种写法错误的,会换成 <code>:prop=&quot;&#39;domains[&#39;+index+&#39;].value&#39;&quot;</code> 这种写法, 其实看了源码之后才明白这两种写法都是正确的.</p>
<ol>
<li>prop 接收的数据类型是 String</li>
<li><code>:prop=&quot;&#39;domains.&#39;+index+&#39;.value&#39;&quot;</code> 和 <code>:prop=&quot;&#39;domains[&#39;+index+&#39;].value&#39;&quot;</code> 这两种传值最终都是转换成了 <code>domains.0.value</code> 字符串，这是一个字符串 而不是通过 <code>domains.0</code> 来取 <code>domains</code> 数组的第一个元素<br>浮上部分源码<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/ElementUI/El-Form/1502856-20181010162553209-120878951.png?raw=true" loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/ElementUI/El-Form/1502856-20181010162743794-1203877402.png?raw=true" loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/ElementUI/El-Form/1502856-20181010162700061-1335666674.png?raw=true" loading="lazy"></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>ElementUI</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>表单循环渲染动态数据</title>
    <url>/2021/09/26/ElementUI/%E8%A1%A8%E5%8D%95%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>不知道大家在写项目的时候有没有遇到过这个需求：<br>“我要把返回的元素都放在表单里，点修改可以一起修改，不用一个一个去点修改”<br>是的，我遇到了</p>
<p>经过我多次尝试，以及查阅各种资料后，终于完美解决了这个需求（不知道大神看来完不完美，反正我觉得很完美）</p>
<p>首先我们要在data中定义参数</p>
<h2 id="在data中定义参数"><a href="#在data中定义参数" class="headerlink" title="在data中定义参数"></a>在data中定义参数</h2><p>如果设置 <code>temp: []</code> 获取数据时直接 push 的话会导致 v-model 不能实时渲染，<br>这是因为 Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>如果你想在对象中添加对象也是可以的，但是会出现 v-model 没绑定的状态，具体原理我也不知</p>
<p>如果直接设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">temp</span>: [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>会报这个错<code>&quot;Invalid prop: type check failed for prop &quot;model&quot;. Expected Object, got Array&quot;</code></p>
<p>因为在 el-form 上绑定了 <code>:model=&quot;temp&quot;</code>,而它只能传递一个对象，所以我们可以将 temp 设置为一个对象，在对象内添加数组，就是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">temp</span>: &#123;</span><br><span class="line">  <span class="attr">formData</span>: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样引入就不会报错了</p>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p>定义完参数就该获取参数值了，可以通过获取列表的进行 push，一般接口返回的数据都是数组格式的，可以将接口返回的值进行 forEach 循环，再将需要的值通过 this.temp.formData.push 添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">getList</span>().<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = response.<span class="property">response</span></span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">temp</span>.<span class="property">formData</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">key</span>: item.<span class="property">key</span>,</span><br><span class="line">        <span class="attr">name</span>: item.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">uuid</span>: item.<span class="property">uuid</span>,</span><br><span class="line">        <span class="attr">value</span>: item.<span class="property">value</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>获取了参数后，可以通过 v-for 循环进行动态渲染，需要注意的点是 prop 的写法，需要与 v-model 使用的属性名相对应，而且要与 rules 相同，可以将 rules 写在行内，但要注意把 el-form 上的 :rules=”rules” 去掉</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;dataForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;temp&quot;</span> <span class="attr">label-position</span>=<span class="string">&quot;right&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;170px&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin:0 50px;&quot;</span> <span class="attr">:close-on-click-modal</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in temp.formData&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:label</span>=<span class="string">&quot;item.name&quot;</span> <span class="attr">:prop</span>=<span class="string">&quot;&#x27;formData.&#x27;+index+&#x27;.value&#x27;&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;&#123;required:true,message:&#x27;请输入&#x27;+item.name+&#x27;的值内容&#x27;,trigger:&#x27;blur&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;item.value&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里使用了 prop 的链式写法<br>因为 formData 是一个数组，’formData.’+index+’.value’ 相当于 ‘formData[‘ + index + ‘].value’，关键在于 prop 传递的是一个字符串<br>以上这两种方式传值最终都是转换成了 formData.0.value 字符串，这是一个字符串，而不是通过 formData.0 来取 formData 数组的第一个元素</p>
<p>如果在过程中经常遇到 <code>Error in mounted hook : Error:please transfer a valid prop path to form item</code> 这个问题，那就去检查一下是不是 prop 和 v-model 是不是匹配的</p>
<h2 id="动态增减表单项"><a href="#动态增减表单项" class="headerlink" title="动态增减表单项"></a>动态增减表单项</h2><p>官方文档：<a href="https://element.eleme.cn/#/zh-CN/component/form">https://element.eleme.cn/#/zh-CN/component/form</a><br>添加一个点击事件就好了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleAdd&quot;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">temp</span>.<span class="property">formData</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">uuid</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p>当使用 v-model 循环渲染表单时，如果出现上传多个图片时，会导致不论点哪个的上传，传递的值都添加到第一个表单上<br>以 input= file 举例，只要在循环时在需要定义名称的地方加上 index 或者 item.id 就可以了<br>在 label 中加上 <code>:for=&quot;&#39;file&#39;+item.id&quot;</code>, input 中加上 <code>:id=&quot;&#39;file&#39;+item.id&quot;</code> 和 <code>:name=&quot;&#39;file&#39;+item.id&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图片&quot;</span> <span class="attr">:prop</span>=<span class="string">&quot;&#x27;formData.&#x27;+index+&#x27;.value&#x27;&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;&#123;required:true,message:&#x27;请选择图片&#x27;,trigger:&#x27;blur&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;item.value&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-show</span>=<span class="string">&quot;item.type==1&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;&#x27;file&#x27;+item.id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;el-button el-button--danger el-button--mini&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:id</span>=<span class="string">&quot;&#x27;file&#x27;+item.id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;&#x27;file&#x27;+item.id&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;uploadImageToChange($event, item)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      上传图片</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>ElementUI</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Test Utils 使用 setValue 赋值失败</title>
    <url>/2022/03/25/Jest/Vue-Test-Utils%E4%BD%BF%E7%94%A8setValue%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="Vue-Test-Utils-使用-setValue-赋值失败"><a href="#Vue-Test-Utils-使用-setValue-赋值失败" class="headerlink" title="Vue Test Utils 使用 setValue 赋值失败"></a>Vue Test Utils 使用 setValue 赋值失败</h2><hr>
<p>Login.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-input ref=&quot;loginForm.username&quot; v-model=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">    &lt;el-input ref=&quot;password&quot; v-model=&quot;password&quot; type=&quot;loginForm.password&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loginForm: &#123;</span><br><span class="line">        username: &#x27;&#x27;,</span><br><span class="line">        password: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="失败例子"><a href="#失败例子" class="headerlink" title="失败例子"></a>失败例子</h3><h4 id="setValue"><a href="#setValue" class="headerlink" title="setValue()"></a>setValue()</h4><p>如文档中所述，如果是输入元素，其值可以在数据中体现如下。<br>但是，当我在像上面这样的自定义组件上运行此代码时，我收到一个错误：<code>wrapper.setValue() cannot be called on this elemen</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Login.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">Login</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;设置input内容&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;测试&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> textInput = wrapper.<span class="title function_">find</span>(<span class="string">&#x27;[type=&quot;text&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(textInput.<span class="title function_">exists</span>()).<span class="title function_">toBe</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> textInput.<span class="title function_">setValue</span>(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    <span class="comment">// 报错：wrapper.setValue() cannot be called on this elemen</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">loginForm</span>.<span class="property">username</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="element-value-value"><a href="#element-value-value" class="headerlink" title="element.value = value"></a>element.value = value</h4><p>按文档所说：<code>textInput.setValue(value)</code> 是接下来这段代码的别名，这样写虽然没有报错，但并未给 <code>textInput</code> 复制成功</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Login.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">Login</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;设置input内容&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> textInput = wrapper.<span class="title function_">find</span>(<span class="string">&#x27;[type=&quot;text&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    textInput.<span class="property">element</span>.<span class="property">value</span> = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">loginForm</span>.<span class="property">username</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    <span class="comment">// wrapper.vm.loginForm.username： &quot;&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><hr>
<p>通过触发输入事件，可以在数据中反映输入值并对其进行测试。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Login.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">Login</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;设置input内容&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="string">&#x27;测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> textInput = wrapper.<span class="title function_">find</span>(<span class="string">&#x27;[type=&quot;text&quot;]&#x27;</span>)</span><br><span class="line">    <span class="comment">// const textInput = wrapper.find(&#123; ref: &#x27;username&#x27; &#125;)</span></span><br><span class="line">    textInput.<span class="property">vm</span>.$emit(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">test</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>*注意：无论你使用哪种方式获取 <code>testInput</code> 元素，在触发输入事件时都要加上 <code>input</code>，否则会导致赋值失败</p>
<p>参考文档：<a href="https://qiita.com/AtsushiEsashika/items/9a9f29fd11dd75f0508f">https://qiita.com/AtsushiEsashika/items/9a9f29fd11dd75f0508f</a></p>
]]></content>
      <categories>
        <category>Jest</category>
      </categories>
      <tags>
        <tag>jest</tag>
        <tag>Vue-Test-Utils</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest-vue单元测试 $route报错</title>
    <url>/2022/03/23/Jest/jest-route/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>在使用 <code>jest</code> 进行单元测试时，含有 <code>$route</code> 的页面会出现报错</p>
<h1 id="获取路由信息"><a href="#获取路由信息" class="headerlink" title="获取路由信息"></a>获取路由信息</h1><p>直接获取路由相关信息返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;fullPath&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;hash&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;matched&quot;</span>: [], <span class="string">&quot;meta&quot;</span>: &#123;&#125;, <span class="string">&quot;name&quot;</span>: <span class="literal">null</span>, <span class="string">&quot;params&quot;</span>: &#123;&#125;, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;query&quot;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过mock设置-route"><a href="#通过mock设置-route" class="headerlink" title="通过mock设置$route"></a>通过mock设置$route</h1><p>相关解决方法通过 <code>mock</code> 设置 <code>$route</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createLocalVue, mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Home&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;get route name&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">Home</span>, &#123;</span><br><span class="line">      <span class="attr">mocks</span>: &#123;</span><br><span class="line">        <span class="attr">$route</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">$route</span>.<span class="property">name</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;Home&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>报错提示 <code>could not overwrite property $route, this is usually caused by a plugin that has added the property as a read-only value</code></p>
<h1 id="localVue"><a href="#localVue" class="headerlink" title="localVue"></a>localVue</h1><p>根据官方文档<a href="https://v1.test-utils.vuejs.org/zh/api/options.html#localvue">vue-test-utils</a>中的 <code>localVue</code> 配置路由相关信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createLocalVue, mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localVue = <span class="title function_">createLocalVue</span>()</span><br><span class="line">localVue.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Home&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;get route name&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">Component</span>, &#123;</span><br><span class="line">      localVue,</span><br><span class="line">      router</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">$route</span>.<span class="property">name</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;Home&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时 <code>wrapper.vm.$route</code> 的返回值是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;fullPath&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;hash&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;matched&quot;</span>: [], <span class="string">&quot;meta&quot;</span>: &#123;&#125;, <span class="string">&quot;name&quot;</span>: <span class="literal">null</span>, <span class="string">&quot;params&quot;</span>: &#123;&#125;, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;query&quot;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>先来看一下路由的导航守卫</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">from</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在导航守卫中，刷新页面后打印的 <code>from</code> 的值与上面的返回值相同。于是我尝试先通过路由跳转至需要获取 <code>$route</code> 的页面再去进行判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createLocalVue, mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localVue = <span class="title function_">createLocalVue</span>()</span><br><span class="line">localVue.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Home&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">Component</span>, &#123;</span><br><span class="line">    localVue,</span><br><span class="line">    router</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;get route name&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="property">vm</span>.<span class="property">$route</span>.<span class="property">name</span>).<span class="title function_">toBe</span>(<span class="string">&#x27;Home&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时 <code>wrapper.vm.$route</code> 的返回值是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;fullPath&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;hash&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;matched&quot;</span>: [&#123;<span class="string">&quot;beforeEnter&quot;</span>: <span class="literal">undefined</span>, <span class="string">&quot;components&quot;</span>: &#123;<span class="string">&quot;default&quot;</span>: <span class="literal">undefined</span>&#125;, <span class="string">&quot;instances&quot;</span>: &#123;&#125;, <span class="string">&quot;matchAs&quot;</span>: <span class="literal">undefined</span>, <span class="string">&quot;meta&quot;</span>: &#123;&#125;, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Home&quot;</span>, <span class="string">&quot;parent&quot;</span>: <span class="literal">undefined</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;props&quot;</span>: &#123;&#125;, <span class="string">&quot;redirect&quot;</span>: <span class="literal">undefined</span>, <span class="string">&quot;regex&quot;</span>: <span class="regexp">/^(?:\/(?=$))?$/i</span>&#125;], <span class="string">&quot;meta&quot;</span>: &#123;&#125;, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Home&quot;</span>, <span class="string">&quot;params&quot;</span>: &#123;&#125;, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="string">&quot;query&quot;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>测试成功！<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/Jest/oh.gif" alt="ohhhhh" loading="lazy"></p>
]]></content>
      <categories>
        <category>Jest</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>jest</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook总结</title>
    <url>/2020/12/27/React/Hook%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="Hook-的简介"><a href="#Hook-的简介" class="headerlink" title="Hook 的简介"></a><strong>Hook 的简介</strong></h1><p><em>Hook</em> 是React16.8的新增特性。它可以让你在不缩写class的情况下使用state以及其他的React特性。</p>
<p><em>Hook</em> 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。<em>Hook</em> 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。</p>
<h3 id="没有破坏性改动"><a href="#没有破坏性改动" class="headerlink" title="没有破坏性改动"></a><strong>没有破坏性改动</strong></h3><p><em>Hook</em> 是：</p>
<ul>
<li><strong>完全可选的。</strong>无需重写任何已有代码就可以在一些组建中尝试 <em>Hook</em>。</li>
<li><strong>100%向后兼容。</strong></li>
<li><strong>现在可用。</strong></li>
</ul>
<p><strong>没有计划从React中移除class。</strong> <em>Hook</em> 为已知React概念提供了更直接的API：props，state，context，refs以及生命周期。</p>
<h1 id="Hook-的使用"><a href="#Hook-的使用" class="headerlink" title="Hook 的使用"></a><strong>Hook 的使用</strong></h1><p><em>Hook</em> 是向下兼容的。</p>
<h2 id="📌State-Hook"><a href="#📌State-Hook" class="headerlink" title="📌State Hook"></a>📌<strong>State Hook</strong></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 声明一个新的叫做 &quot;count&quot; 的 state 变量  </span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>usestate</code> 就是一个 <em>Hook</em> 。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。<code>useState</code> 会返回一对值：<strong>当前</strong>状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 <code>this.setState</code>，但是它不会把新的 state 和旧的 state 进行合并。</p>
<p><code>useState</code> 唯一的参数就是初始 state。在上面的例子中，我们的计数器是从零开始的，所以初始 state 就是 <code>0</code>。值得注意的是，不同于 <code>this.state</code>，这里的 state 不一定要是一个对象 —— 如果你有需要，它也可以是。这个初始 state 参数只有在第一次渲染时会被用到。</p>
<h4 id="声明多个-state-变量"><a href="#声明多个-state-变量" class="headerlink" title="声明多个 state 变量"></a>声明多个 state 变量</h4><p>你可以在一个组件中多次使用 State Hook:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ExampleWithManyStates</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 声明多个 state 变量！</span></span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = <span class="title function_">useState</span>(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = <span class="title function_">useState</span>([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组解构的语法让我们在调用 <code>useState</code> 时可以给 state 变量取不同的名字。当然，这些名字并不是 <code>useState</code> API 的一部分。React 假设当你多次调用 <code>useState</code> 的时候，你能保证每次渲染时它们的调用顺序是不变的。后面我们会再次解释它是如何工作的以及在什么场景下使用。</p>
<h2 id="⚡️-Effect-Hook"><a href="#⚡️-Effect-Hook" class="headerlink" title="⚡️ Effect Hook"></a>⚡️ Effect Hook</h2><p><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</p>
<p>下面这个组件在 React 更新 DOM 后会设置一个页面标题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 componentDidMount 和 componentDidUpdate:  </span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;    <span class="comment">// 使用浏览器的 API 更新页面标题    </span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>; </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟 <code>useState</code> 一样，你可以在组件中多次使用 <code>useEffect</code></p>
<h1 id="✌️-Hook-的规则"><a href="#✌️-Hook-的规则" class="headerlink" title="✌️ Hook 的规则"></a>✌️ <strong>Hook 的规则</strong></h1><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>
<ul>
<li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 基础类型,Symbol和变量声明</title>
    <url>/2020/12/29/React/TypeScript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B-Symbol%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h2 id="1-布尔值"><a href="#1-布尔值" class="headerlink" title="1.布尔值"></a>1.布尔值</h2><p>最基本的数据类型就是简单的true/false，在JavaScript和TypeScript里叫做<code>boolean</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-数字"><a href="#2-数字" class="headerlink" title="2.数字"></a>2.数字</h2><p>和JavaScript一样，TypeScript 里的所有数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><p>JavaScript的另一项基本操作是处理网页或服务器端的文本数据。和其他语言一样使用string表示文本数据类型。可以使用双引号( “ )或单引号( ‘ )表示字符串。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用模板字符串，它可以定义多行文本和内嵌表达式。这种字符串是被反引号包围( ` ),并且以${ expr }这种形式嵌入表达式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span>,</span></span><br><span class="line"><span class="string">    I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>

<p>与下面定义<code>sentence</code>的方式效果相同：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><p>TypeScript像JavaScript一样可以操作数组元素。有两种方式可以定义数组。</p>
<p>​    (1) 在元素类型后面接上 <code>[ ]</code>，表示此类型元素组成的一个数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>​    (2) 使用数组泛型，<code>Array&lt;元素类型&gt;</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="5-元组-Tuple"><a href="#5-元组-Tuple" class="headerlink" title="5.元组 Tuple"></a>5.元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h2 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h2><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，从0开始为元素编号。也可以手动指定成员的数值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>此时元素编号从1开始。</p>
<p>也可以全部采用手动赋值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]; <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<h2 id="7-Any"><a href="#7-Any" class="headerlink" title="7. Any"></a>7. Any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-Void"><a href="#8-Void" class="headerlink" title="8. Void"></a>8. Void</h2><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-Null-和-Undefined"><a href="#9-Null-和-Undefined" class="headerlink" title="9. Null 和 Undefined"></a>9. Null 和 Undefined</h2><p>TypeScript 里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>当指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免 <em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>
<h2 id="10-Never"><a href="#10-Never" class="headerlink" title="10. Never"></a>10. Never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-Object"><a href="#11-Object" class="headerlink" title="11. Object"></a>11. Object</h2><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的 API 。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="12-类型断言"><a href="#12-类型断言" class="headerlink" title="12.类型断言"></a>12.类型断言</h2><p>有时候你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。</p>
<p>​    (1)  “尖括号形式”</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>​    (2) <code>as</code>语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>两种形式是等价的。但当你在 TypeScript 里使用 JSX 时，只有 <code>as</code>语法断言是被允许的。</p>
<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。  <code>let</code>在很多方面与<code>var</code>是相似的，但是可以避免在JavaScript里常见的一些问题。 <code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p>
<h2 id="1-var-声明"><a href="#1-var-声明" class="headerlink" title="1. var 声明"></a>1. <code>var</code> 声明</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>也可以在函数内部定义变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在其它函数内部访问相同的变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">g</span>(); <span class="comment">// returns 11;</span></span><br></pre></td></tr></table></figure>

<p><code>g</code>可以获取到<code>f</code>函数里定义的<code>a</code>变量。 每当 <code>g</code>被调用时，它都可以访问到<code>f</code>里的<code>a</code>变量。 即使当 <code>g</code>在<code>f</code>已经执行完后才被调用，它仍然可以访问及修改<code>a</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="title function_">g</span>();</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// return 2</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p><code>var</code>声明的作用域。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">shouldInitialize: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldInitialize) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>);  <span class="comment">// return &#x27;10&#x27;</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>); <span class="comment">// return &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>x</code>是定义在*<code>if</code>语句里面<em>，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有什么影响。 有些人称此为</em> <code>var</code>作用域<em>或</em>函数作用域*。 函数参数也使用函数作用域。</p>
<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> currentRow = matrix[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            sum += currentRow[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：里层的<code>for</code>循环会覆盖变量<code>i</code>，因为所有<code>i</code>都引用相同的函数作用域内的变量。这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>
<h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" class="headerlink" title="捕获变量怪异之处"></a>捕获变量怪异之处</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>会在若干毫秒的延时后执行一个函数</p>
<p>返回的结果是：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传给<code>setTimeout</code>的每一个函数表达式实际上都引用了相同作用域里的同一个<code>i</code>。</p>
</blockquote>
<h2 id="2-let-声明"><a href="#2-let-声明" class="headerlink" title="2.let 声明"></a>2.<code>let</code> 声明</h2><p>除了名字不同外， <code>let</code>与<code>var</code>的写法一致。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用<code>let</code>声明一个变量，它使用的是<em>词法作用域</em>或<em>块作用域</em>。 不同于使用 <code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或<code>for</code>循环之外是不能访问的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input) &#123;</span><br><span class="line">        <span class="comment">// Still okay to reference &#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> b = a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error: &#x27;b&#x27; doesn&#x27;t exist here</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了2个变量<code>a</code>和<code>b</code>。 <code>a</code>的作用域是<code>f</code>函数体内，而<code>b</code>的作用域是<code>if</code>语句块里。</p>
<p>在<code>catch</code>语句里声明的变量也具有同样的作用域规则。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;oh no!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oh well.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: &#x27;e&#x27; doesn&#x27;t exist here</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br></pre></td></tr></table></figure>

<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 <em>暂时性死区</em>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">a++; <span class="comment">// illegal to use &#x27;a&#x27; before it&#x27;s declared;</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>

<p>我们仍然可以在一个拥有块作用域变量被声明前<em>获取</em>它。 只是我们不能在变量声明前去调用那个函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// okay to capture &#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// 运行时应该抛出错误</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>

<h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>使用<code>var</code>声明时，它不在乎你声明多少次；你只会得到1个。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子里，所有<code>x</code>的声明实际上都引用一个<em>相同</em>的<code>x</code>，并且这是完全有效的代码。 这经常会成为bug的来源。 但 <code>let</code>声明不允许重复声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 错误，不能在1个作用域里多次声明`x`</span></span><br></pre></td></tr></table></figure>

<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span>; <span class="comment">// error: interferes with parameter declaration</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span>; <span class="comment">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>块级作用域变量需要在不同的块里声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">condition, x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// returns 0</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>, <span class="number">0</span>);  <span class="comment">// returns 100</span></span><br></pre></td></tr></table></figure>

<h3 id="块级作用域变量的获取"><a href="#块级作用域变量的获取" class="headerlink" title="块级作用域变量的获取"></a>块级作用域变量的获取</h3><p>每次进入一个作用域时，它创建了一个变量的 <em>环境</em>。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;<span class="keyword">function</span> <span class="title function_">theCityThatAlwaysSleeps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getCity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> city = <span class="string">&quot;Seattle&quot;</span>;</span><br><span class="line">        getCity = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> city;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getCity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们已经在<code>city</code>的环境里获取到了<code>city</code>，所以就算<code>if</code>语句执行结束后我们仍然可以访问它。</p>
<p>当<code>let</code>声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 <em>每次迭代</em>都会创建这样一个新作用域。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的输出结果是：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="3-const-声明"><a href="#3-const-声明" class="headerlink" title="3.const 声明"></a>3.<code>const</code> 声明</h2><p><code>const</code> 声明是声明变量的另一种方式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>与<code>let</code>声明相似，但它们被赋值后不能再改变。它们拥有与 <code>let</code>相同的作用域规则，但是不能对它们重新赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> kitty = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Aurora&quot;</span>,</span><br><span class="line">    <span class="attr">numLives</span>: numLivesForCat,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">kitty = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Danielle&quot;</span>,</span><br><span class="line">    <span class="attr">numLives</span>: numLivesForCat</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all &quot;okay&quot;</span></span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Rory&quot;</span>;</span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Kitty&quot;</span>;</span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">kitty.<span class="property">numLives</span>--;</span><br></pre></td></tr></table></figure>

<p><code>const</code>变量的内部状态是可修改的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-解构"><a href="#4-解构" class="headerlink" title="4.解构"></a>4.解构</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure>

<p>可以在数组里使用<code>...</code>语法进行解构：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>

<p>可以在对象里使用<code>...</code>语法创建剩余变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class="line"><span class="keyword">let</span> total = passthrough.<span class="property">b</span> + passthrough.<span class="property">c</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<h4 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h4><p>可以给属性以不同的名字：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>

<p>可以将 <code>a: newName1</code> 读做 “<code>a</code> 作为 <code>newName1</code>“。 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newName1 = o.<span class="property">a</span>;</span><br><span class="line"><span class="keyword">let</span> newName2 = o.<span class="property">b</span>;</span><br></pre></td></tr></table></figure>

<p>这里的冒号<em>不是</em>指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125;: &#123;<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>&#125; = o;</span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>解构也能用于函数声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h4><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这会令<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code>和<code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p>
<p>也可以展开对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><code>search</code>的值为<code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span>, ...defaults &#125;;</span><br></pre></td></tr></table></figure>

<p>defaults<code>里的</code>food<code>属性会重写</code>food: “rich”。</p>
<h1 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h1><p><code>symbol</code>是一种新的原生类型，就像<code>number</code>和<code>string</code>一样。</p>
<p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 可选的字符串key</span></span><br></pre></td></tr></table></figure>

<p>Symbols是不可改变且唯一的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">sym2 === sym3; <span class="comment">// false, symbols是唯一的</span></span><br></pre></td></tr></table></figure>

<p>像字符串一样，symbols也可以被用做对象属性的键。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sym]: <span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[sym]); <span class="comment">// &quot;value&quot;</span></span><br></pre></td></tr></table></figure>

<p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    [getClassNameSymbol]()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p>
<p>symbols的列表：</p>
<h2 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a><code>Symbol.hasInstance</code></h2><p>方法，会被<code>instanceof</code>运算符调用。构造器对象用来识别一个对象是否是其实例。</p>
<h2 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><code>Symbol.isConcatSpreadable</code></h2><p>布尔值，表示当在一个对象上调用<code>Array.prototype.concat</code>时，这个对象的数组元素是否可展开。</p>
<h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a><code>Symbol.iterator</code></h2><p>方法，被<code>for-of</code>语句调用。返回对象的默认迭代器。</p>
<h2 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a><code>Symbol.match</code></h2><p>方法，被<code>String.prototype.match</code>调用。正则表达式用来匹配字符串。</p>
<h2 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a><code>Symbol.replace</code></h2><p>方法，被<code>String.prototype.replace</code>调用。正则表达式用来替换字符串中匹配的子串。</p>
<h2 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a><code>Symbol.search</code></h2><p>方法，被<code>String.prototype.search</code>调用。正则表达式返回被匹配部分在字符串中的索引。</p>
<h2 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a><code>Symbol.species</code></h2><p>函数值，为一个构造函数。用来创建派生对象。</p>
<h2 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a><code>Symbol.split</code></h2><p>方法，被<code>String.prototype.split</code>调用。正则表达式来用分割字符串。</p>
<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><code>Symbol.toPrimitive</code></h2><p>方法，被<code>ToPrimitive</code>抽象操作调用。把对象转换为相应的原始值。</p>
<h2 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a><code>Symbol.toStringTag</code></h2><p>方法，被内置方法<code>Object.prototype.toString</code>调用。返回创建对象时默认的字符串描述。</p>
<h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a><code>Symbol.unscopables</code></h2><p>对象，它自己拥有的属性会被<code>with</code>作用域排除在外。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react生命周期</title>
    <url>/2020/12/18/React/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="react生命周期："><a href="#react生命周期：" class="headerlink" title="react生命周期："></a>react生命周期：</h2><p>生命周期函数是自动执行的，具体某个生命周期想干什么，需要我们自己去写</p>
<h2 id="react组件的生命周期过程"><a href="#react组件的生命周期过程" class="headerlink" title="react组件的生命周期过程"></a>react组件的生命周期过程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/376b440b163aa510e17258a6a0213b31.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h3 id="常用生命周期："><a href="#常用生命周期：" class="headerlink" title="常用生命周期："></a>常用生命周期：</h3><p>1.constructor（构造函数）</p>
<p>2.getDerive的StateFromProps</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(props, state)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p> getDerive的StateFromProp会在render方法前调用，并且在初始挂在及后续更新时都会被调用，它应返回一个对象来更新state，如果返回null则不返回任何值。</p>
<p>state的值在任何时候都取决于props。</p>
<p>3.shouldComponentUpdate</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(nextProps,nextState)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>根据shouldComponentUpdate()的返回值，判断react组件的输出是否受当前state或props更改的影响。默认行为是state每次发生变化组件都回重新渲染。大部分情况下，应遵循默认行为。</p>
<p>当props或state发生变化时，shouldComponentUpdate()会在渲染执行前被调用。首次渲染或使用forceUpdate()时不会调用该方法。</p>
<p>4.render： 当render被调用时，会检查this.props和this.state的变化并返回虚拟dom。</p>
<p>5.getSnapshotBeforeUpdate</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(prevProps,prevState)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>getSnapshotBeforeUpdate()在最近一次渲染输出前调用。它使组件能在发生改变前从dom捕获一些信息。此生命周期的任何返回值将作为参数传递给componentDidUpdate()。</p>
<p>6.componentDidMount</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>()</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>componentDidMount()会在组件挂载后立即调用。此处是实例化请求的好地方</p>
<p>可以在componentDidMount()里<strong>直接调用setState()。</strong>它将触发额外渲染，但此渲染发生在浏览器更新屏幕之前。保证了即使在render()两次调用的情况下，用户也不会看到中间状态。谨慎使用该模式，因为它可能会导致性能问题。</p>
<p>7.componentDidMount</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>componentDidMount()会在更新后被立即调用。首次渲染不会执行此方法。</p>
<p>也可以在componentDidMount()中<strong>直接调用setState()</strong>,但请注意<strong>它必须被包裹在一个条件语句中</strong>，否则会在导致死循环。</p>
<p>8.componentWillUnmount</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p> componentWillUnmount()会在组件卸载及销毁之前直接调用。此方法中执行必要的清理操作，例如：清理timer，取消网络请求或清除在componentDidMount()中创建的订阅等。</p>
<p>componentWillUnmount()中**不应调用setState()**，因为该组件将永远不会重新渲染，组件实例卸载后，将永远不会挂载它。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator和for...of循环</title>
    <url>/2020/12/14/Script/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="一、Iterator（遍历器）的概念"><a href="#一、Iterator（遍历器）的概念" class="headerlink" title="一、Iterator（遍历器）的概念"></a>一、Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据结构的成员能够按某种次序排列</li>
<li> ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li>
</ol>
<p>Iterator 的遍历过程：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li>
</ol>
<h2 id="二、默认-Iterator-接口"><a href="#二、默认-Iterator-接口" class="headerlink" title="二、默认 Iterator 接口"></a>二、默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>
<h2 id="三、调用-Iterator-接口的场合"><a href="#三、调用-Iterator-接口的场合" class="headerlink" title="三、调用 Iterator 接口的场合"></a>三、调用 Iterator 接口的场合</h2><p><strong>1、解构赋值</strong></p>
<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<p><strong>2、扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<p><strong>3、yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<p><strong>4、其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p>
<p>例：</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h2 id="四、for-of和for-in的区别"><a href="#四、for-of和for-in的区别" class="headerlink" title="四、for-of和for-in的区别"></a>四、for-of和for-in的区别</h2><p><code>for...of</code>循环本质上就是调用这个接口产生的遍历器，</p>
<p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p>
<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收机制</title>
    <url>/2021/01/20/Script/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Js 的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>
<p>在 Js 中，Js 的执行环境会负责管理代码执行过程中使用的内存。</p>
<h1 id="2-变量的生命周期"><a href="#2-变量的生命周期" class="headerlink" title="2. 变量的生命周期"></a>2. 变量的生命周期</h1><p>当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。</p>
<h1 id="3-Js-垃圾回收方式"><a href="#3-Js-垃圾回收方式" class="headerlink" title="3. Js 垃圾回收方式"></a>3. Js 垃圾回收方式</h1><p>Js执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)。</p>
<h2 id="1-标记清除-mark-and-sweep"><a href="#1-标记清除-mark-and-sweep" class="headerlink" title="(1) 标记清除(mark and sweep)"></a>(1) 标记清除(mark and sweep)</h2><p>大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。</p>
<p>垃圾收集器给内存中的所有变量都加上标记，然后<strong>去掉环境中的变量以及被环境中的变量引用的变量的标记</strong>。在此之后再被加上的标记的变量即为需要回收的变量，因为环境中的变量已经无法访问到这些变量。</p>
<h2 id="2-引用计数-reference-counting"><a href="#2-引用计数-reference-counting" class="headerlink" title="(2) 引用计数(reference counting)"></a>(2) 引用计数(reference counting)</h2><p>这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。</p>
<p>该方式会引起内存泄漏的原因是它不能解决循环引用的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sample</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a=&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> b=&#123;&#125;;</span><br><span class="line">    a.<span class="property">prop</span> = b;</span><br><span class="line">    b.<span class="property">prop</span> = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下每次调用sample()函数，a和b的引用计数都是2，会使这部分内存永远不会被释放，即内存泄漏。</p>
<blockquote>
<p>低版本IE中有一部分对象并不是原生 JS 对象。例如，其 BOM和DOM中的对象就是使用C++以COM(Component Object Model)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。</p>
<p><strong>因此即使IE的 js引擎是用的标记清除来实现的，但是 js访问COM对象如BOM,DOM还是基于引用计数的策略的</strong>，也就是说只要在IE中设计到COM对象，也就会存在循环引用的问题。</p>
</blockquote>
<p>当一个DOM元素和一个原生的js对象之间的循环引用时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;eleId&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">property</span> = ele;</span><br><span class="line">ele.<span class="property">property</span> = obj;</span><br></pre></td></tr></table></figure>

<p>添加 obj.property = null;ele.property = null;即可解除原生JS对象与DOM元素之间的连接。</p>
<p>当闭包中创建循环引用时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj= <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;eleId&quot;</span>);</span><br><span class="line">    obj.<span class="property">onclick</span> = <span class="keyword">function</span> <span class="title function_">innerfunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码创建了一个作为obj元素处理程序的闭包，而这个闭包则又创建了一个循环引用。obj引用了document.getElementById(“element”)，而document.getElementById(“ele　　Id”)的onclick方法会引用包括 obj 以内的外部环境中的变量，所谓“外部环境”包括了包含函数的整个活动对象，所以一定会包括 obj（即使闭包没有对 obj 进行直接的引用，例如上文程序中没有 obj.id 出现，包含函数的活动对象（obj）中也依旧会保存一个引用）。</p>
<p>可以改成下面这个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj= <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> id = obj.<span class="property">id</span>;<span class="comment">//将obj副本保存于变量id中，则不会使obj元素处理程序的闭包创建循环引用</span></span><br><span class="line">    obj.<span class="property">onclick</span> = <span class="keyword">function</span> <span class="title function_">innerfunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    ele = <span class="literal">null</span>;<span class="comment">//手动断开 obj 对 document.getElemengById(&quot;element&quot;)的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型与原型链</title>
    <url>/2021/01/15/Script/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h1><p>每个对象都可以有一个原型<code>__proto__</code>，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了。</p>
<h1 id="原型指针"><a href="#原型指针" class="headerlink" title="原型指针"></a>原型指针</h1><p>构造函数有两个属性： <code>__proto__</code> 和 prototype</p>
<h2 id="prototype："><a href="#prototype：" class="headerlink" title="prototype："></a>prototype：</h2><p>prototype属性，它是<strong>函数所独有的</strong>，是从<strong>一个函数指向一个对象</strong>。它的含义是<strong>函数的原型对象</strong>，也就是这个函数所创建的实例的原型对象；这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法，我们把这个对象叫做原型对象。</p>
<h2 id="proto-："><a href="#proto-：" class="headerlink" title="__proto__："></a><code>__proto__</code>：</h2><p><code>__proto__</code> 是原型链查询中实际用到的，它总是指向 prototype（指向构造函数的原型对象），它是<strong>对象独有的。</strong></p>
<h2 id="constructor："><a href="#constructor：" class="headerlink" title="constructor："></a>constructor：</h2><blockquote>
<p>每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。</p>
</blockquote>
<p>可以使用constructor属性，所有的实例对象都可以访问constructor属性，constructor属性是创建实例对象的函数的引用。我们可以使用constructor属性验证实例的原型类型。</p>
<p> 由于constructor属性仅仅是原始构造函数的引用，因此我们可以使用该属性创建新的对象。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>__proto__</code> 是原型链查询中实际用到的，他总是指向 prototype 。</li>
<li> prototype 是函数所独有的，在定义构造函数时自动创建。</li>
<li>每个对象都有 <code>__proto__</code> 属性，函数这个特殊对象除了具有 <code>__proto__</code> 属性，还有特有的原型属性 prototype 。prototype对象默认有两个属性，constructor属性和<code>__proto__</code>属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而<code>__proto__</code>是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型</title>
    <url>/2020/12/20/Script/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h1><ol>
<li>字符串类型</li>
<li>数值类型</li>
<li>布尔值类型</li>
<li>undefined类型</li>
<li>null类型</li>
</ol>
<h3 id="一、字符串类型"><a href="#一、字符串类型" class="headerlink" title="一、字符串类型"></a>一、字符串类型</h3><p>用于存储和处理文本</p>
<p>字符串可以存储一系列字符，字符串可以是插入到引号中的任何字符。可以使用单引号或双引号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;This is a string&quot;</span>；</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;This is a string&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>可以使用下标来访问字符串中的每个字符,字符串的下标从0开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="number">8</span>]); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>字符串中可以使用引号，但不能与字符串的引号相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;It&#x27;s alright&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p><strong>字符串长度：</strong></p>
<p>字符串可以使用length来获取长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt.<span class="property">length</span>); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p><strong>特殊字符：</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>tab（制表符）</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
</tbody></table>
<h3 id="二、数值类型"><a href="#二、数值类型" class="headerlink" title="二、数值类型"></a>二、数值类型</h3><p>JavaScript只有一种数值类型，使用时是否使用小数点都可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x1 = <span class="number">34.00</span>;     <span class="comment">// 带小数点</span></span><br><span class="line"><span class="keyword">var</span> x2 = <span class="number">34</span>;        <span class="comment">// 不带小数点</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>超大或超小的数值可以用科学计数法来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">123e5</span>;      <span class="comment">// 12300000</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">123e-5</span>;     <span class="comment">// 0.00123</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h3 id="三、布尔类型"><a href="#三、布尔类型" class="headerlink" title="三、布尔类型"></a>三、布尔类型</h3><p>布尔值只有两个值：true 或 false。</p>
<p>布尔值经常用在条件测试中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h3 id="四、undefined类型、null类型"><a href="#四、undefined类型、null类型" class="headerlink" title="四、undefined类型、null类型"></a>四、undefined类型、null类型</h3><p>undefined 属性用于存放 JavaScript 的 undefined 值。</p>
<p>无法使用 for/in 循环来枚举 undefined 属性，也不能用 delete 运算符来删除它。</p>
<p>undefined 不是常量，可以把它设置为其他值。</p>
<p>当尝试读取不存在的对象属性时也会返回 undefined。</p>
<p>只能用 === 运算来测试某个值是否是未定义的，因为 == 运算符认为 undefined 值等价于 null。</p>
<p>null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。</p>
<p>null为空</p>
<h3 id="五、-和"><a href="#五、-和" class="headerlink" title="五、== 和 ==="></a>五、== 和 ===</h3><p><strong>区别：</strong></p>
<p>使用==判断是否相等时，会先将两个数据转为同一类型再进行比较。如果两个值类型不同，也有可能相等</p>
<p>==： </p>
<ol>
<li>Number类型与boolean类型，比较前先将Boolean转换为数值。</li>
<li>Number类型与字符串类型，比较前先将字符串转换为数值</li>
<li>Number类型与undefined类型，结果为 false</li>
<li>Number类型与null类型，结果为 false</li>
<li>如果两个都是字符串，比较字符序列</li>
<li>如果两个都是对象，比较的是对象的引用地址</li>
<li>null == undefined //true</li>
<li>NaN与任何值（包括NaN）比较结果都为false</li>
</ol>
<p>===：</p>
<ol>
<li>如果两个值类型相同，再进行三个等号(===)的比较，如果类型不同，就一定不相等</li>
<li>如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</li>
<li>如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</li>
<li>如果两个值都是true，或是false，那么相等</li>
<li>如果两个值都引用同一个对象或是函数，那么相等，否则不相等</li>
<li>如果两个值都是null，或是undefined，那么相等</li>
</ol>
<p>[] === [] //false</p>
<p>undefined === undefined //true</p>
<p>[] == []  //false</p>
<p>undefined == undefined //true</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深浅拷贝</title>
    <url>/2020/12/16/Script/JavaScript%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>前提：拷贝是针对对象的操作，当想复制一个对象时，才存在深浅拷贝之分</strong></p>
<h2 id="一、浅拷贝"><a href="#一、浅拷贝" class="headerlink" title="一、浅拷贝"></a>一、浅拷贝</h2><blockquote>
<p>仅仅是复制了引用，彼此之间的操作会互相影响</p>
</blockquote>
<p>1.<strong>Object.assign()</strong></p>
<p>对象只有一层是使用，当对象嵌套对象时，深层的对象无法被拷贝到</p>
<p>2.<strong>lodash的clone方法</strong></p>
<p>\3. <strong>…操作符</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kobe&#x27;</span>, <span class="attr">address</span>:&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2= &#123;... obj1&#125;</span><br><span class="line">obj1.<span class="property">address</span>.<span class="property">x</span> = <span class="number">200</span>;</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>4.<strong>Array.prototype.concat</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">concat</span>();    </span><br><span class="line">arr2[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>5.<strong>Array.prototype.slice</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.<span class="title function_">slice</span>();</span><br><span class="line">arr3[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="二、深拷贝"><a href="#二、深拷贝" class="headerlink" title="二、深拷贝"></a>二、深拷贝</h2><blockquote>
<p>深拷贝会另外创造一个一模一样的对象，新旧对象不共享内存，因此修改其中的一个对象不会改到另一个对象。</p>
</blockquote>
<p>1.<strong>JSON.parse(JSON.stringify())</strong></p>
<p>可以处理数组和对象的深拷贝，但是不能处理函数和正则，因为这两者基于这两个函数处理后得到的结果不再是正则/函数</p>
<p>缺点：</p>
<ol>
<li><p>会忽略undefined</p>
</li>
<li><p>会忽略symbol</p>
</li>
<li><p>不能序列化函数</p>
</li>
<li><p>不能解决循环引用的对象</p>
</li>
</ol>
<p>2.<strong>lodash的cloneDeep函数</strong></p>
<p>3.<strong>jQuery.extend函数</strong></p>
<p>4.<strong>Messagechannel</strong></p>
<p>如果所拷贝的对象含有内置对象，但不包含函数，可以使用。可以拷贝undefined和循环引用的对象</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise对象</title>
    <url>/2020/12/15/Script/Promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="一、Promise-的含义"><a href="#一、Promise-的含义" class="headerlink" title="一、Promise 的含义"></a>一、Promise 的含义</h2><p>Promise是抽象异步处理对象以及对其进行各种操作的组件。</p>
<p><strong>Promise 对象的两个特点:</strong></p>
<p>1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p>
<ul>
<li>pending: 初始状态，不是成功或失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>
<p><strong>Promise对象的优缺点</strong></p>
<p>优点：可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p>缺点：</p>
<ul>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li>
<li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段</li>
</ul>
<h2 id="二、Promise-创建"><a href="#二、Promise-创建" class="headerlink" title="二、Promise 创建"></a>二、Promise 创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 调用resolve */</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 异步操作失败 调用reject */</span></span><br><span class="line">    <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。</p>
<h2 id="三、Promise-prototype-then"><a href="#三、Promise-prototype-then" class="headerlink" title="三、Promise.prototype.then()"></a>三、Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;谢谢光临&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="四、Promise-prototype-catch"><a href="#四、Promise-prototype-catch" class="headerlink" title="四、Promise.prototype.catch()"></a>四、Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎&#x27;</span>)</span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;谢谢光临&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>当promise抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Promise对象解决回调地狱层层嵌套的问题。</p>
<p>通过<code>then</code>方法分别制定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ECMAScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy</title>
    <url>/2020/12/29/Script/Proxy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Proxy 用于修改某些操作的默认行为。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作。</p>
<h2 id="Proxy-支持的13种拦截操作："><a href="#Proxy-支持的13种拦截操作：" class="headerlink" title="Proxy 支持的13种拦截操作："></a>Proxy 支持的13种拦截操作：</h2><ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h1 id="2-Proxy-实例的方法"><a href="#2-Proxy-实例的方法" class="headerlink" title="2. Proxy 实例的方法"></a>2. Proxy 实例的方法</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><code>get</code>方法的用法： 拦截读取操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Prop name \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span> <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure>

<p>如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propertyKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET &#x27;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// &quot;GET foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p><code>set</code>方法第四个参数的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身。</p>
<p>如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<p>严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    <span class="comment">// 无论有没有下面这一行，都会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">p</span>()</span><br><span class="line"><span class="comment">// &quot;I am the proxy&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice);</span><br><span class="line"><span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure>

<h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>

<p><code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line"><span class="comment">// 张三 不及格</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure>

<h2 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h2><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>construct()</code>方法可以接受三个参数。</p>
<ul>
<li><code>target</code>：目标对象。</li>
<li><code>args</code>：构造函数的参数数组。</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called: &#x27;</span> + args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span></span><br><span class="line"><span class="comment">// &quot;called: 1&quot;</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;construct&#x27; on proxy: trap returned non-object (&#x27;1&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: p is not a constructor</span></span><br></pre></td></tr></table></figure>

<p><code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, handler);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h2><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure>

<p>目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h2><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span> <span class="comment">// 不会生效</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>
<p>如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>
<h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h2><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;tar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;wat&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_foo&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h2><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p><code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>
<h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h2><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure>

<h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h2><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for...in</code>循环</li>
</ul>
<p>拦截对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<p><code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>)]: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;static&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>), <span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a valid property name</span></span><br></pre></td></tr></table></figure>

<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap result did not include &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap returned extra keys but proxy target</span></span><br></pre></td></tr></table></figure>

<h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h2><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;preventExtensions&#x27; on proxy: trap returned truish but the prox</span></span><br></pre></td></tr></table></figure>

<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called&#x27;</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>
<p>下面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Changing the prototype is forbidden&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>

<p>该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h1 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3. Proxy.revocable()"></a>3. Proxy.revocable()</h1><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h1 id="4-this-问题"><a href="#4-this-问题" class="headerlink" title="4. this 问题"></a>4. this 问题</h1><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    _name.<span class="title function_">set</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jane&#x27;</span>);</span><br><span class="line">jane.<span class="property">name</span> <span class="comment">// &#x27;Jane&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p>Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2015-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;getDate&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="5-实例：Web-服务的客户端"><a href="#5-实例：Web-服务的客户端" class="headerlink" title="5. 实例：Web 服务的客户端"></a>5. 实例：Web 服务的客户端</h1><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="title function_">createWebService</span>(<span class="string">&#x27;http://example.com/data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">service.<span class="title function_">employees</span>().<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseUrl</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">&#x27;/&#x27;</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol</title>
    <url>/2020/12/11/Script/Symbol/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>JavaScript7种数据类型：</p>
<ol>
<li>undefined</li>
<li>null</li>
<li>布尔值(Boolean)</li>
<li>字符串(String)</li>
<li>数值(Number)</li>
<li>对象(Object)</li>
<li>Symbol</li>
</ol>
<h3 id="1-为什么ES6要引入Symbol？"><a href="#1-为什么ES6要引入Symbol？" class="headerlink" title="1. 为什么ES6要引入Symbol？"></a>1. 为什么ES6要引入Symbol？</h3><p>ES5的对象属性名都是字符串，容易引起属性名冲突，而Symbol保证每个属性名都是独一无二的，从根本上防止属性名冲突。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>以上代码中，s是一个独一无二的值，typeof判断的结果是s是Symbol数据类型，而不是其他类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo) s2 // Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot; s2.toString() // &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>以上代码中s1与s2是两个Symbol值，如果不加参数，则输出都是Symbol()，不利于区分，有了参数，相当于为他们添加了描述，便于区分。</p>
<ol>
<li>当Symbol的参数是一个对象时，就会调用toString方法，转为字符串后生成一个Symbol值。</li>
<li>Symbol函数的参数只是对当前Symbol值的描述，因此相同参数的Symbol函数的返回值不相等。</li>
<li>Symbol值不能与其他类型的值进行运算，会报错</li>
<li>Symbol值可以显示为字符串</li>
<li>Symbol值也可以转为布尔值，但不能转为数值</li>
</ol>
<h3 id="2-Symbol-prototype-description"><a href="#2-Symbol-prototype-description" class="headerlink" title="2.Symbol.prototype.description"></a>2.Symbol.prototype.description</h3><p>创建Symbol是可以添加一个描述</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">//sym的描述就是字符串foo</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>但读取这个描述要将Symbol显示转为字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym)</span><br><span class="line"></span><br><span class="line">sym.<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>ES2019提供了一个实例属性description，直接返回Symbol描述</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h3 id="3-Symbol作为属性名"><a href="#3-Symbol作为属性名" class="headerlink" title="3.Symbol作为属性名"></a>3.Symbol作为属性名</h3><p>由于Symbol值都是不相等的，所以Symbol值可以作为标识符，用于对象属性名，可以保证不会出现同名属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;[mySymbol]: <span class="string">&#x27;Hello!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123;<span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法结果相同</span></span><br><span class="line"></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>以上通过中括号结构和Object.defineProperty，将对象的属性名指定为一个Symbol值</p>
<p>Symbol值作为对象属性名是，不能点运算符</p>
<p>因为点运算符后面总是字符串，所以不会读取Symbol值所代指的值，导致属性名实际上是一个字符串，而不是Symbol值</p>
<p>在对象内部使用Symbol值定义属性时，Symbol值必须放在中括号中，如果不放在中括号中，该属性的键名就是字符串，而不是Symbol值。</p>
<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的</p>
<p><strong>Symbol值作为属性名时，该属性是公开属性，不是私有属性</strong></p>
<h3 id="4-属性名的遍历"><a href="#4-属性名的遍历" class="headerlink" title="4.属性名的遍历"></a>4.属性名的遍历</h3><p>Symbol作为属性名遍历对象时，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</p>
<p>但它也不是私有属性，有一个Object.getOwnPropertySymbols()方法可以获取指定对向所有Symbol属性名，该方法返回一个数组，成员是当前对象所有用作属性名的Symbol值。</p>
<h3 id="5-Symbol-for-Symbol-ketFor"><a href="#5-Symbol-for-Symbol-ketFor" class="headerlink" title="5.Symbol.for(), Symbol.ketFor()"></a>5.Symbol.for(), Symbol.ketFor()</h3><p>当我们希望使用同一个Symbol值，Symbol.for()方法可以做到。他接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值，有则返回这个Symbol值，没有则新建一个以该字符串为名称的Symbol值，并注册到全局。</p>
<h3 id="6-内置Symbol值"><a href="#6-内置Symbol值" class="headerlink" title="6.内置Symbol值"></a><strong>6.内置Symbol值</strong></h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置Symbol值，指向语言内部使用方法。</p>
<p><strong>1、 Symbol.hasInstance</strong></p>
<p>对象的Symbol.hasInstance属性，指向一个内部方法。当期他对象使用Instanceof运算符，判断是否为该对象的实例时，会调用这个方法。</p>
<p><strong>2、Symbol.isConcatSpreadable</strong></p>
<p>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。</p>
<p><strong>3、Symbol.species</strong></p>
<p>对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<p><strong>4、Symbol.match</strong></p>
<p>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<p><strong>5、Symbol.replace</strong></p>
<p>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p>
<p><strong>6、Symbol.search</strong></p>
<p>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值</p>
<p><strong>7、 Symbol.split</strong></p>
<p>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p>
<p><strong>8、Symbol.iterator</strong></p>
<p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
<p><strong>9、 Symbol.toPrimitive</strong></p>
<p>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><strong>10、 Symbol.toStringTag</strong></p>
<p>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。</p>
<p><strong>11、 Symbol.unscopables</strong></p>
<p>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>class的基本用法和继承</title>
    <url>/2020/12/28/Script/class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><h2 id="1-类的由来"><a href="#1-类的由来" class="headerlink" title="1.类的由来"></a>1.类的由来</h2><p>JavaScript语言中，生成实例对象的传统方法是通过构造函数。</p>
<p>ES6 提供了更接近传统语言的写法，引入了class（类）这个概念作为对象的模板。通过<code>class</code>关键字可以定义类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>用class方法改写上面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;,&#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与构造函数<code>Point</code>是一致的。</p>
<p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228184947750.png" alt="image-20201228184947750" loading="lazy"></p>
<p>通过控制台打印输出可以看到：类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stuff&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">b.<span class="title function_">doStuff</span>() <span class="comment">// &quot;stuff&quot;</span></span><br></pre></td></tr></table></figure>

<p>构造函数的<code>prototype</code>属性，在ES6中的“类”上继续存在。类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身</p>
<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228185718334.png" alt="image-20201228185718334" loading="lazy"></p>
<p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<p>当<code>toString()</code>方法是<code>Point</code>的内部定义方法时，是不可枚举的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Point</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<p>而当采用 ES5 的写法时，<code>toString()</code>方法就是可枚举的。</p>
<hr>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>
<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>
<hr>
<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228190756620.png" alt="image-20201228190756620" loading="lazy"></p>
<p>实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">point.<span class="title function_">toString</span>() <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;x&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;y&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">point.<span class="property">__proto__</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;Oops&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">p2.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。</p>
<p>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<hr>
<h3 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h3><p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span> = <span class="number">123</span>; <span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span> <span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<hr>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可采用表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">&#x27;getArea&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Square``类的方法名是getArea</code>，是从表达式中得到的。</p>
<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228191835077.png" alt="image-20201228191835077" loading="lazy"></p>
<hr>
<h3 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyName</span> = <span class="keyword">class</span> <span class="title class_">Me</span> &#123;</span><br><span class="line">  <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Me</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyName</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">MyName</span>();</span><br><span class="line">inst.<span class="title function_">getClassName</span>() <span class="comment">// Me</span></span><br><span class="line"><span class="title class_">Me</span>.<span class="property">name</span> <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228192239913.png" alt="image-20201228192239913" loading="lazy"></p>
<hr>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）严格模式</strong></p>
<p>​        类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<p><strong>（2）不存在提升</strong></p>
<p>​        类不存在变量提升（hoist）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此时报错是因为在使用前没有声明变量，ES6不会把类的声明提前，所以导致了报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Foo</span> = <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不会报错，因为<code>Bar</code>继承<code>Foo</code>时，<code>Foo</code>已经定义过了。</p>
<p><strong>（3）name 属性</strong></p>
<p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Point</span>.<span class="property">name</span> <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<p><strong>（4）Generator 方法</strong></p>
<p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args</span> = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">args</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>
<p><strong>（5）this 的指向</strong></p>
<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">print</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">print</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line"><span class="title function_">printName</span>(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p><code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，从而导致找不到<code>print</code>方法而报错。</p>
<p>解决：</p>
<p> 1.在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">printName</span> = <span class="variable language_">this</span>.<span class="property">printName</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用箭头函数。  箭头函数内部的<code>this</code>总是指向定义时所在的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getThis</span> = <span class="function">() =&gt;</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">myObj.<span class="title function_">getThis</span>() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">classMethod</span>() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">classMethod</span>()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p><code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），如果在实例上调用，则会抛出一个错误表示不存在该方法。</p>
<p>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">baz</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">bar</span>() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。静态方法可以与非静态方法重名。</p>
<p>父类的静态方法，可以被子类继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">classMethod</span>() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>
<p>静态方法也是可以从<code>super</code>对象上调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">classMethod</span>() + <span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">classMethod</span>() <span class="comment">// &quot;hello, too&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-实例属性的新写法"><a href="#3-实例属性的新写法" class="headerlink" title="3.实例属性的新写法"></a>3.实例属性的新写法</h2><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</p>
<p>定义在constructor()方法中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在类的最顶层：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级，不需要在实例属性前面加上<code>this</code>。</p>
<hr>
<h2 id="4-静态属性"><a href="#4-静态属性" class="headerlink" title="4.静态属性"></a>4.静态属性</h2><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>
<p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20201228194140327.png" alt="image-20201228194140327" loading="lazy"></p>
<p><code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>
<p> 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">prop</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种新写法的好处在于：符合相关代码放在一起的代码组织原则，而且不容易让人忽略，也比较简洁。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<hr>
<h2 id="5-私有方法和私有属性"><a href="#5-私有方法和私有属性" class="headerlink" title="5.私有方法和私有属性"></a>5.私有方法和私有属性</h2><h3 id="现有解决方案"><a href="#现有解决方案" class="headerlink" title="现有解决方案"></a>现有解决方案</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。只能通过变通方法模拟实现。</p>
<p><strong>1.在命名上加以区别。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_bar</span>(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  <span class="title function_">_bar</span>(<span class="params">baz</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">snaf</span> = baz;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p><strong>2.将私有方法移出类</strong>，因为类内部的所有方法都是对外可见的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.<span class="title function_">call</span>(<span class="variable language_">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">baz</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">snaf</span> = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。</p>
<p><strong>3.利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="title class_">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">myClass</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">baz</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">myClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myClass.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// [ &#x27;constructor&#x27;, &#x27;foo&#x27;, Symbol(bar) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="私有属性提案"><a href="#私有属性提案" class="headerlink" title="私有属性提案"></a>私有属性提案</h3><p>为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#count <span class="comment">// 报错</span></span><br><span class="line">counter.#count = <span class="number">42</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>私有属性也可以设置 getter 和 setter 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get #<span class="title function_">x</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> #xValue; &#125;</span><br><span class="line">  set #<span class="title function_">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>来完成。</p>
<p>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</p>
<p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p>
<hr>
<h2 id="6-new-terget-属性"><a href="#6-new-terget-属性" class="headerlink" title="6. new.terget 属性"></a>6. new.terget 属性</h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = <span class="title class_">Person</span>.<span class="title function_">call</span>(person, <span class="string">&#x27;张三&#x27;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>Class 内部调用<code>new.target</code>，返回当前 Class。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Rectangle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>子类继承父类时，<code>new.target</code>会返回子类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Rectangle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>在函数外部使用<code>new.target</code>会报错。</p>
<hr>
<h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>
<p>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="variable language_">super</span>(x, y);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>
<p>父类的静态方法，也会被子类继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">hello</span>()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p><code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>时，也继承了<code>A</code>的静态方法。</p>
<hr>
<h2 id="2-Object-getPrototypeOf"><a href="#2-Object-getPrototypeOf" class="headerlink" title="2. Object.getPrototypeOf()"></a>2. Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">ColorPoint</span>) === <span class="title class_">Point</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<hr>
<h2 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3.super关键字"></a>3.super关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>1.<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 会报错。</p>
<p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>() <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p><code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>
<p>2.<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">p</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">p</span>()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">p</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">m</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p>
<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p><code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<p>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以解析代码的时候就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">valueOf</span>() <span class="keyword">instanceof</span> B); <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p><code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
<p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">toString</span>(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-类的-prototype-属性和-proto-属性"><a href="#4-类的-prototype-属性和-proto-属性" class="headerlink" title="4.类的 prototype 属性和 __proto__ 属性"></a>4.类的 prototype 属性和 <code>__proto__</code> 属性</h2><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><p>每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<hr>
<h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 __proto__ 属性"></a>实例的 <code>__proto__</code> 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// false</span></span><br><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Ha&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>() <span class="comment">// &quot;Ha&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5.原生构造函数的继承"></a>5.原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。</p>
<p>ECMAScript 的原生构造函数：</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">MyArray</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">colors.<span class="property">length</span>  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure>

<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<h2 id="6-Mixin-模式的实现"><a href="#6-Mixin-模式的实现" class="headerlink" title="6. Mixin 模式的实现"></a>6. Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>
<p><code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>history</title>
    <url>/2021/01/28/Script/history/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><code>History</code> 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>History</code> 接口不继承于任何属性。</p>
<h2 id="History-length-（只读）"><a href="#History-length-（只读）" class="headerlink" title="History.length      （只读）"></a><code>History.length</code>      （只读）</h2><p>返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。例如，在一个新的选项卡加载的一个页面中，这个属性返回1。</p>
<h2 id="History-scrollRestoration"><a href="#History-scrollRestoration" class="headerlink" title="History.scrollRestoration"></a><code>History.scrollRestoration</code></h2><p>允许web应用程序在历史导航上显示的设置默认滚动恢复行为。此属性可以是自动或者手动的。</p>
<h2 id="History-state-（只读）"><a href="#History-state-（只读）" class="headerlink" title="History.state      （只读）"></a><code>History.state</code>      （只读）</h2><p>返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待 <code>popstate</code> 事件而查看状态的方式。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><code>History</code> 接口不继承任何方法。</p>
<h2 id="History-back"><a href="#History-back" class="headerlink" title="History.back()"></a><code>History.back()</code></h2><p>在浏览器历史记录里前往上一页，用户可点击浏览器左上角的返回，等价于 <code>history.go(-1)</code></p>
<blockquote>
<p>当浏览器会话历史记录处于第一页时调用此方法没有效果，而且也不会报错。</p>
</blockquote>
<h2 id="History-forward"><a href="#History-forward" class="headerlink" title="History.forward()"></a><code>History.forward()</code></h2><p>在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进，等价于 <code>history.go(1)</code></p>
<blockquote>
<p>当浏览器历史栈处于最顶端时( 当前页面处于最后一页时 )调用此方法没有效果也不报错。</p>
</blockquote>
<h2 id="History-go"><a href="#History-go" class="headerlink" title="History.go()"></a><code>History.go()</code></h2><p>通过当前页面的相对位置从浏览器历史记录加载页面，参数为-1的时候为上一页，参数为1的时候为下一页。如果当前页为第一页，前面已经没有页面了，传参的值为-1，那么这个方法没有任何效果也不会报错。调用没有参数的 <code>go() </code>方法或者不是整数的参数时也没有效果。</p>
<h2 id="History-pushState"><a href="#History-pushState" class="headerlink" title="History.pushState()"></a><code>History.pushState()</code></h2><p>按指定的名称和URL将数据push进会话历史栈，数据对DOM进行不透明处理，可以指定任何可以被序列化的JavaScript对象。</p>
<h2 id="History-replaceState"><a href="#History-replaceState" class="headerlink" title="History.replaceState()"></a><code>History.replaceState()</code></h2><p>按指定的数据名称和URL更新历史栈上的最新入口。这个数据被DOM进行了不透明处理。可以指定任何可以被序列化的JavaScript对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Window 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>new的模拟实现</title>
    <url>/2021/01/13/Script/new%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><blockquote>
<p><strong><code>new</code> 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>可以对已定义的对象添加新的属性。例如，给 <code>car1</code> 添加一个新的属性 <code>color</code>，并给这个属性赋值 “<code>black</code>“，但这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，则必须将该属性添加到 <code>Car</code> 对象类型的定义中。</p>
<p>也可以使用 <code>Function.prototype</code> 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">car1 = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car2 = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car1.<span class="property">color</span>);    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&quot;original color&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car1.<span class="property">color</span>);    <span class="comment">// original color</span></span><br><span class="line"></span><br><span class="line">car1.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car1.<span class="property">color</span>);   <span class="comment">// black</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car1.<span class="property">__proto__</span>.<span class="property">color</span>) <span class="comment">//original color</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car2.<span class="property">__proto__</span>.<span class="property">color</span>) <span class="comment">//original color</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car1.<span class="property">color</span>)  <span class="comment">// black</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car2.<span class="property">color</span>) <span class="comment">// original color</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你没有使用 <code>new</code> 运算符， <strong>构造函数会像其他的常规函数一样被调用，</strong> 并<em>不会创建一个对象<strong>。</strong></em>在这种情况下， <code>this</code> 的指向也是不一样的。</p>
</blockquote>
<h1 id="对象类型和对象实例"><a href="#对象类型和对象实例" class="headerlink" title="对象类型和对象实例"></a>对象类型和对象实例</h1><p>假设你要创建一个汽车的对象类型。你希望这个类型叫做car，这个类型具备make, model, year等属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 mycar 的对象，并给他的属性指定值</span></span><br><span class="line"><span class="keyword">var</span> mycar = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">make</span>); <span class="comment">// Eagle</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">model</span>); <span class="comment">// Talon TSi</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">year</span>); <span class="comment">// 1993</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过调用 new 来创建任意个汽车对象</span></span><br><span class="line"><span class="keyword">var</span> kenscar = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Nissan&quot;</span>, <span class="string">&quot;300ZX&quot;</span>, <span class="number">1992</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">make</span>); <span class="comment">// Nissan</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">model</span>); <span class="comment">// 300ZX</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(carl.<span class="property">year</span>); <span class="comment">// 1992</span></span><br></pre></td></tr></table></figure>

<h1 id="对象属性为其他对象"><a href="#对象属性为其他对象" class="headerlink" title="对象属性为其他对象"></a>对象属性为其他对象</h1><p>假设你定义了一个对象叫做 <code>person</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, sex</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化两个新的 person 对象</span></span><br><span class="line"><span class="keyword">var</span> rand = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Rand McNally&quot;</span>, <span class="number">33</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ken = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ken Jones&quot;</span>, <span class="number">39</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 car 的定义，添加一个值为 person 对象的 owner 属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year, owner</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">owner</span> = owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化新的对象</span></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>, rand);</span><br><span class="line"><span class="keyword">var</span> car2 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Nissan&quot;</span>, <span class="string">&quot;300ZX&quot;</span>, <span class="number">1992</span>, ken);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象时，并没有传字符串或数字给owner，而是传了对象 rand 和 ken 。可以通过 car2.owner.name来获取</span></span><br><span class="line">car2.<span class="property">owner</span>.<span class="property">name</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>screenfull全屏</title>
    <url>/2022/03/09/Script/screenfulljs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="在-vue-中使用-screenfull-js-全屏插件"><a href="#在-vue-中使用-screenfull-js-全屏插件" class="headerlink" title="在 vue 中使用 screenfull.js 全屏插件"></a>在 vue 中使用 screenfull.js 全屏插件</h1><p>首先使用 npm 下载 screenfull.js 插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save screenfull</span><br></pre></td></tr></table></figure>

<p>在需要用到的组件中引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> screenfull <span class="keyword">from</span> <span class="string">&#x27;screenfull&#x27;</span></span><br></pre></td></tr></table></figure>

<p>定义一个全屏点击事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;el-icon-full-screen&quot; @click=&quot;clickFullscreen&quot;&gt;点击全屏&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import screenfull from &#x27;screenfull&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Screenfull&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isclick: false // 当 isclick 为false时，为非全屏状态 为true时，为全屏状态</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 点击 ESC 退出全屏状态</span><br><span class="line">    const self = this // 如果不定义 this 使用时会报错</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, function() &#123;</span><br><span class="line">      if (!self.checkFull()) &#123;</span><br><span class="line">        if (self.isclick) &#123;</span><br><span class="line">          self.isFullscreen = false</span><br><span class="line">          self.isclick = !self.isclick</span><br><span class="line">          self.$emit(&#x27;onChange&#x27;, false)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          self.isFullscreen = false</span><br><span class="line">          self.isclick = !self.isclick</span><br><span class="line">          self.$emit(&#x27;onChange&#x27;, false)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods() &#123;</span><br><span class="line">    clickFullscreen() &#123;</span><br><span class="line">      this.isclick = !this.isclick</span><br><span class="line">      screenfull.toggle()</span><br><span class="line">      this.isFullscreen = true</span><br><span class="line">      if (this.isclick) &#123; // isclick 为true 控制为全屏</span><br><span class="line">        this.$emit(&#x27;onChange&#x27;, true)</span><br><span class="line">      &#125; else &#123; // isclick 为false 控制为非全屏</span><br><span class="line">        this.$emit(&#x27;onChange&#x27;, false)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    checkFull() &#123;</span><br><span class="line">      var isFull = document.webkitIsFullScreen // 点击进入全屏状态时为 true， 退出全屏状态时为 false</span><br><span class="line">      return isFull</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>super关键字</title>
    <url>/2021/01/11/Script/super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><code>super</code>关键字既可以当作函数使用，也可以当做对象使用。</p>
<h1 id="在函数中使用super"><a href="#在函数中使用super" class="headerlink" title="在函数中使用super"></a>在函数中使用super</h1><p>当<code>super</code>作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>() <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p><code>new.target</code>指向当前正在执行的函数。在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在对象中使用super"><a href="#在对象中使用super" class="headerlink" title="在对象中使用super"></a>在对象中使用super</h1><p><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中指向父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="title function_">p</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">p</span>()) <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>()</span><br></pre></td></tr></table></figure>

<p>子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">p</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">m</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>
<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p><code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;static&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure>

<p><code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
<p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">valueOf</span>() <span class="keyword">instanceof</span> B); <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p><code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
<p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">toString</span>(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>秒转化成 时分秒</title>
    <url>/2022/04/11/Script/s%E8%BD%AC%E4%B8%BAh-m-s/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//秒转化成 时分秒</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">secondToDate</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> h = <span class="title class_">Math</span>.<span class="title function_">floor</span>(result / <span class="number">3600</span>);</span><br><span class="line">  <span class="keyword">var</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((result / <span class="number">60</span> % <span class="number">60</span>));</span><br><span class="line">  <span class="keyword">var</span> s = <span class="title class_">Math</span>.<span class="title function_">floor</span>((result % <span class="number">60</span>));</span><br><span class="line">  <span class="keyword">return</span> result = h + <span class="string">&quot;小时&quot;</span> + m + <span class="string">&quot;分钟&quot;</span> + s + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向和改变方法</title>
    <url>/2021/01/14/Script/this%E6%8C%87%E5%90%91%E5%92%8C%E6%94%B9%E5%8F%98%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><blockquote>
<p>this是JavaScript语言的一个关键字。</p>
</blockquote>
<p>它代表函数运行时自动生成的一个内部对象，只能在函数内部使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着函数使用的场合不同， <code>this </code>的值会发生变化。但有一个总的原则： <code>this</code> 就是函数运行时所在的环境对象（是调用函数的那个对象）。</p>
<h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><p>1.如果是一般函数，<code>this</code> 指向全局对象window</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>2.对象方法中调用，<code>this</code> 指向调用该方法的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>3.作为构造函数调用，<code>this</code> 指向创建出来的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>4.在严格模式下，<code>this</code> 指向undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">// udnefined</span></span><br></pre></td></tr></table></figure>

<p>5.通过事件绑定的方法，<code>this</code> 指向绑定事件的对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    oBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.定时器函数， <code>this</code> 指向 <code>window</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<h1 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h1><p><strong>1. call() 方法、apply() 方法、bind() 方法</strong></p>
<p>共同点： 第一个参数为 <code>this</code> 指向改变后的指向。若第一参数为null/undefined，this默认指向window</p>
<p><strong>call(无数个参数)</strong></p>
<ul>
<li>第一个参数： 改变 <code>this</code> 指向</li>
<li>第二个参数： 实参</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="title class_">Person</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>

<p>**apply(两个参数) **</p>
<ul>
<li>第一个参数： 改变 <code>this</code> 指向</li>
<li>第二个参数： 数组（里面为实参）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="title class_">Person</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>

<p>**bind(无数个参数) **</p>
<ul>
<li>第一个参数： 改变 <code>this</code> 指向</li>
<li>第二个参数： 实参</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// window</span></span><br><span class="line">fn.<span class="title function_">bind</span>(<span class="title class_">Person</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(); <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Window 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是变量提升？什么是严格模式？</title>
    <url>/2020/12/30/Script/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="JavaScript-变量提升"><a href="#JavaScript-变量提升" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h1><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span>; <span class="comment">// 变量 x 设置为 5</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.<span class="property">innerHTML</span> = x;                     <span class="comment">// 在元素中显示 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明 x</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明 x</span></span><br><span class="line">x = <span class="number">5</span>; <span class="comment">// 变量 x 设置为 5</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.<span class="property">innerHTML</span> = x;                     <span class="comment">// 在元素中显示 x</span></span><br></pre></td></tr></table></figure>

<p>以上两个例子皆可执行，不会报错。因为第一个例子进行了变量提升。</p>
<blockquote>
<p>变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = <span class="number">3.14</span>;                <span class="comment">// 报错 (x 未定义)</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-初始化不会提升"><a href="#JavaScript-初始化不会提升" class="headerlink" title="JavaScript 初始化不会提升"></a>JavaScript 初始化不会提升</h2><p><strong>JavaScript 仅提升声明，而不提升初始化</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">elem.<span class="property">innerHTML</span> = x + <span class="string">&quot; &quot;</span> + y; <span class="comment">// x 为：5，y 为：7</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">elem.<span class="property">innerHTML</span> = <span class="string">&quot;x 为：&quot;</span> + x + <span class="string">&quot;，y 为：&quot;</span> + y; <span class="comment">// x 为：5，y 为：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br></pre></td></tr></table></figure>

<p>第二个实例的 y 输出了 <strong>undefined</strong>，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</p>
<p>相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"><span class="keyword">var</span> y;     <span class="comment">// 声明 y</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">elem.<span class="property">innerHTML</span> = <span class="string">&quot;x 为：&quot;</span> + x + <span class="string">&quot;，y 为：&quot;</span> + y; <span class="comment">// x 为：5，y 为：undefined</span></span><br><span class="line"></span><br><span class="line">y = <span class="number">7</span>;    <span class="comment">// 设置 y 为 7</span></span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-变量提升-1"><a href="#JavaScript-变量提升-1" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h1><p>JavaScript可以进行变量提升，也可以进行函数提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo1); <span class="comment">// [Function: foo1]</span></span><br><span class="line"><span class="title function_">foo1</span>(); <span class="comment">// foo1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">foo2</span>(); <span class="comment">// TypeError: foo2 is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span> () &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo2&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但函数提升只会提升函数声明，而不会提升函数表达式。</p>
<h1 id="JavaScript-严格模式"><a href="#JavaScript-严格模式" class="headerlink" title="JavaScript 严格模式"></a>JavaScript 严格模式</h1><p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
<p>通过<strong>use strict</strong>指令指定代码在严格条件下执行。</p>
<p>严格模式下不能使用未声明的变量。</p>
<h2 id="严格模式声明"><a href="#严格模式声明" class="headerlink" title="严格模式声明"></a>严格模式声明</h2><p>严格模式通过在脚本或函数的头部添加 <strong>use strict</strong>; 表达式来声明。</p>
<h2 id="为什么使用严格模式？"><a href="#为什么使用严格模式？" class="headerlink" title="为什么使用严格模式？"></a>为什么使用严格模式？</h2><ul>
<li>消除代码运行的一些不合理、不严谨、不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>减少一些怪异行为</li>
</ul>
<h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><p>1.不允许使用未声明的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// 报错 (x 未定义)</span></span><br></pre></td></tr></table></figure>

<p>​    对象也是一个变量，在严格模式下同样受限</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = &#123;<span class="attr">p1</span>:<span class="number">10</span>, <span class="attr">p2</span>:<span class="number">20</span>&#125;; <span class="comment">// 报错 (x 未定义)</span></span><br></pre></td></tr></table></figure>

<p>2.不允许删除变量或对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>3.不允许删除函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">x</span>(<span class="params">p1, p2</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>4.不允许变量重名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">x</span>(<span class="params">p1, p1</span>) &#123;&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>5.不允许使用八进制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">010</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>6.不允许使用转义字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = \<span class="number">010</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>7.不允许对只读属性赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">value</span>:<span class="number">0</span>, <span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>8.不允许对一个使用getter方法读取的属性进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">get</span> <span class="title function_">x</span>() &#123;<span class="keyword">return</span> <span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>9.不允许删除一个不允许删除的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>10.变量名不能使用 “eval” 字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>11.变量名不能使用 “arguments” 字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">arguments</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>12.由于一些安全原因，在作用域 eval() 创建的变量不能被调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> (<span class="string">&quot;var x = 2&quot;</span>);</span><br><span class="line">alert (x); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>13.禁止this关键字指向全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span></span><br></pre></td></tr></table></figure>

<p>​    使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">f</span>();<span class="comment">// 报错，this未定义</span></span><br></pre></td></tr></table></figure>

<h2 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h2><p>严格模式新增了一些保留关键字，变量名使用保留关键字时将会报错。</p>
<ul>
<li>implements</li>
<li>interface</li>
<li>let</li>
<li>package</li>
<li>private</li>
<li>protected</li>
<li>public</li>
<li>static</li>
<li>yield</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> public = <span class="number">1500</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p> “use strict” 指令只允许出现在脚本或函数的开头。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是防抖和节流？</title>
    <url>/2020/12/24/Script/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><strong>1.定义：</strong></p>
<p>防抖是指在一定时间内再次触发此事件，会清空上一次的事件重新开始，如果制定时间内没有再次触发事件，那么这个事件才会执行</p>
<p>例如：input输入信息,不可能每次按下都发起一个ajax请求,可以等一段时间内不输入了之后在发起请求</p>
<p><strong>2.代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AntiShake</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)  <span class="comment">// 每当用户输入的时候把前一个 setTimeout 清除掉</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 创建一个新的 setTimeout</span></span><br><span class="line">            execute.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;防抖&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ipt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt&#x27;</span>);</span><br><span class="line">ipt.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title class_">AntiShake</span>(execute)); <span class="comment">//防抖    </span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p><strong>1.定义：</strong></p>
<p>节流是指在一定时间内同一事件只能触发一次，只有超过这个时间才会再次触发</p>
<p>例如：验证码60秒内只能获取一次，只有超过60秒才可以再次获取</p>
<p><strong>2.代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>; <span class="comment">// 通过闭包缓存一个标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123; <span class="comment">// 判断flag是否为true，不为true则return</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span> <span class="comment">//将flag设置为false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 将外部传入的函数放在setTimeout中</span></span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 代码执行完毕将flag改回true</span></span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">innerWidth</span>, e.<span class="property">target</span>.<span class="property">innerHeight</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">throttle</span>(execute)); <span class="comment">// 节流</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP//wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的length属性</title>
    <url>/2021/01/05/Script/%E5%87%BD%E6%95%B0%E7%9A%84length%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h1><p><strong>函数的length</strong> 属性即函数的形参个数。</p>
<table>
<thead>
<tr>
<th>Function.length 属性的属性特性：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>writerable</td>
<td>false</td>
</tr>
<tr>
<td>enumerable</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>true</td>
</tr>
</tbody></table>
<p>length 是函数对象的一个属性值，指<strong>该函数有多少个必须要传入的参数，即形参的个数。</strong> <strong>形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。</strong> 与之对比的是， <code>arguments.length</code> 是函数被调用时实际传参的个数。</p>
<h1 id="Function-构造器的属性"><a href="#Function-构造器的属性" class="headerlink" title=" Function 构造器的属性"></a><code> Function</code> 构造器的属性</h1><p><code>Function</code> 构造器本身也是个Function。它的 <strong><code>length</code> 属性值为 1</strong> 。该属性 Writable: <code>false</code>, Enumerable: <code>false</code>, Configurable: <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Function构造器的属性的length为1</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">length</span>); <span class="comment">// 1    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params">a</span>)&#123;&#125;.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;&#125;.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*2.如果函数内部是通过arguments调用参数，而没有实际定义参数的话,length 只会的得到 0。*/</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(test1.<span class="property">length</span>); <span class="comment">//0</span></span><br><span class="line">   <span class="title function_">test1</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h1 id="ES6的函数length属性"><a href="#ES6的函数length属性" class="headerlink" title="ES6的函数length属性"></a>ES6的函数length属性</h1><p>ES6指定了默认值以后，<strong>函数的length属性，将返回没有指定默认值的参数个数。</strong>也就是说，指定了默认值后，length属性将失真。下面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。</p>
<p>这时因为length属性的含义是，该函数预期传入的参数个数。<strong>某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span> (<span class="params">a</span>)&#123;&#125;).<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>)&#123;&#125;).<span class="property">length</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params">a, b, c = <span class="number">5</span></span>)&#123;&#125;).<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同时，这里的rest参数也不会计入length属性。*/</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params">...args</span>)&#123;&#125;).<span class="property">length</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了*/</span> </span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a = <span class="number">0</span>, b, c</span>)&#123;&#125;).<span class="property">length</span>; <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a, b = <span class="number">1</span>, c</span>)&#123;&#125;).<span class="property">length</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平数组转树形结构</title>
    <url>/2022/04/20/Script/%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>有多个数组a, b, c，需求是将多个数组合并成一个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>concat()<br>合并多个数组，不影响原数组(会造成内存浪费)，不能处理嵌套数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r = a.<span class="title function_">concat</span>(b)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br><span class="line">b <span class="comment">// [4, 5, 6]</span></span><br><span class="line">r <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>如果 a 数组有10000个元素, b 数组也有有10000个元素, 那么数组r就有20000个元素, 这种方式占用了2倍的内存。a = b = null;就会被垃圾回收机制回收。</p>
</li>
<li><p>基于for循环 - push()<br>没有concat的内存浪费，看上去土而且不好维护, 只能合并两个数组，会改变原数组，不能处理嵌套数组。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> b) &#123;</span><br><span class="line">  a.<span class="title function_">push</span>(b[i])</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">b <span class="comment">// [4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>apply<br>简洁高效，能实现多个数组合并, 会改变原数组, 并且能够实现深度嵌套。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.<span class="property">push</span>.<span class="title function_">apply</span>(a, b)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">b <span class="comment">// [4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>更优美的push<br>多个数组合并, 会改变原数组, 效率比较高</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line">a.<span class="title function_">push</span>(...b, ...c)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">b <span class="comment">// [4, 5, 6]</span></span><br><span class="line">c <span class="comment">// [7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>为什么 Array.concat 这么慢？<br>合并拥有大小为 10 的数组 10000 次，.concat 的速度为 0.40 ops/sec（操作每秒），而 .push 的速度是 378 ops/sec。也就是说 push 比 concat 快了整整 945 倍！这种差异可能不是线性的，但在这种小规模数据量上已经很明显了。</p>
<p>这与它们的运行机制有很大的关系：在合并数组的时候，.concat 创建了一个新的数组，而 .push 只是修改了第一个数组。这些额外的操作（将第一个数组的元素添加到返回的数组里）就是拖慢了 .concat 速度的关键。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>属性描述符</title>
    <url>/2021/01/03/Script/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>Object.defineProperty(obj,  prop,  descriptor)</p>
<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><p><code>obj</code>  要定义属性的对象。</p>
<p><code>prop</code>  要定义或修改的属性的名称或<code>Symbol</code>。</p>
<p><code>descriptor</code>  要定义或修改的属性描述符。</p>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><p>被传递给函数的对象。</p>
<blockquote>
<p>在 ES6 中，由于Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而 <code>Object.defineProperty</code> 是定义key为Symbol的属性的方法之一。</p>
</blockquote>
<h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（<code>for...in</code> 或 <code>Object.keys</code>方法），可以改变这些属性的值，也可以<strong>删除</strong>这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 <code>Object.defineProperty()</code> 添加的属性值是不可修改（immutable）的。</p>
<p><em>*<em>数据描述符</em>和*存取描述符</em>。**</p>
<p><em>数据描述符</em> ：是一个具有值的属性，该值可以是可写的，也可以是不可写的。</p>
<p><em>存取描述符</em>：是由 getter 函数和 setter 函数所描述的属性。</p>
<p>一个描述符只能是这两者其中之一；不能同时是两者。</p>
<p>两种描述符都是对象。它们共享以下可选键值（默认值是指在使用 <code>Object.defineProperty()</code> 定义属性时的默认值）：</p>
<p><code>configurable</code>   可配置的</p>
<p>当且仅当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。<br><strong>默认为</strong> **<code>false</code>**。</p>
<p><code>enumerable</code>    可枚举的</p>
<p>当且仅当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中。<br>**默认为 <code>false</code>**。</p>
<p><code>value</code>    值</p>
<p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br>**默认为 <code>undefined</code>**。</p>
<p><code>writable</code>   可写的</p>
<p>当且仅当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<code>赋值运算符</code>改变。<br><strong>默认为 <code>false</code>。</strong></p>
<p><strong>存取描述符</strong>还具有以下可选键值：</p>
<p><code>get</code></p>
<p>属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。<br>**默认为 <code>undefined</code>**。</p>
<p><code>set</code></p>
<p>属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。<br>**默认为 <code>undefined</code>**。</p>
<h2 id="描述符默认值汇总："><a href="#描述符默认值汇总：" class="headerlink" title="描述符默认值汇总："></a>描述符默认值汇总：</h2><ul>
<li>拥有布尔值的键 <code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 的默认值都是 <code>false</code>。</li>
<li>属性值和函数的键 <code>value</code>、<code>get</code> 和 <code>set</code> 字段的默认值为 <code>undefined</code>。</li>
</ul>
<h2 id="描述符可拥有的键值："><a href="#描述符可拥有的键值：" class="headerlink" title="描述符可拥有的键值："></a>描述符可拥有的键值：</h2><table>
<thead>
<tr>
<th></th>
<th>configurable</th>
<th>enumberable</th>
<th>value</th>
<th>writable</th>
<th>set</th>
<th>get</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>存取描述符</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<p>如果一个描述符不具有 <code>value</code>、<code>writable</code>、<code>get</code> 和 <code>set</code> 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 <code>value</code> 或 <code>writable</code> 和 <code>get</code> 或 <code>set</code> 键，则会产生一个异常。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平数组转树形结构</title>
    <url>/2021/11/23/Script/%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h5 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h5><h6 id="扁平数组"><a href="#扁平数组" class="headerlink" title="扁平数组"></a>扁平数组</h6><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张大大&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;项目经理&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小亮&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品leader&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;03&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小美&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UIleader&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老马&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术leader&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老王&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试leader&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;06&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老李&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;运维leader&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;07&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小丽&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品经理&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;08&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大光&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品经理&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;09&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小高&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;03&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UI设计师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小刘&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小华&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小李&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小赵&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小强&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小涛&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;06&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;运维工程师&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h6 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h6><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张大大&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;项目经理&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小亮&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品leader&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;07&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小丽&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品经理&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;08&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大光&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品经理&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;03&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小美&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UIleader&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;09&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小高&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;03&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UI设计师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老马&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术leader&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小刘&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小华&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小李&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;04&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老王&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试leader&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小赵&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小强&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;05&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;测试工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;06&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;老李&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;运维leader&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小涛&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;06&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;运维工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h5 id="结构转换"><a href="#结构转换" class="headerlink" title="结构转换"></a>结构转换</h5><h6 id="「扁平数组」转「树形结构」"><a href="#「扁平数组」转「树形结构」" class="headerlink" title="「扁平数组」转「树形结构」"></a>「扁平数组」转「树形结构」</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">treeing</span> (arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> tree = []</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="comment">// 一个新的带children的结构</span></span><br><span class="line">    <span class="keyword">let</span> newItem = map[item.<span class="property">id</span>] = &#123;</span><br><span class="line">      ...item,</span><br><span class="line">      <span class="attr">children</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map[item.<span class="property">pid</span>]) &#123; <span class="comment">// 父节点已存进map则在父节点的children添加新元素</span></span><br><span class="line">      <span class="keyword">let</span> parent = map[item.<span class="property">pid</span>]</span><br><span class="line">      parent.<span class="property">children</span>.<span class="title function_">push</span>(newItem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有父节点，在根节点添加父节点</span></span><br><span class="line">      tree.<span class="title function_">push</span>(newItem)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="「树形结构」转「扁平数组」"><a href="#「树形结构」转「扁平数组」" class="headerlink" title="「树形结构」转「扁平数组」"></a>「树形结构」转「扁平数组」</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span> (tree, arr = []) &#123;</span><br><span class="line">  tree.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;children, ...props&#125; = item</span><br><span class="line">    <span class="comment">// 添加除了children的属性</span></span><br><span class="line">    arr.<span class="title function_">push</span>(props)</span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      <span class="comment">// 递归将所有节点加入到结果集中</span></span><br><span class="line">      <span class="title function_">flatten</span>(children, arr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关文档：<a href="https://juejin.cn/post/6997445260632653861">https://juejin.cn/post/6997445260632653861</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组排序</title>
    <url>/2021/11/22/Script/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="数组排序的几个方法"><a href="#数组排序的几个方法" class="headerlink" title="数组排序的几个方法"></a>数组排序的几个方法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>将数组进行循环，将两个相邻元素进行比较，如果两者之间，一方大于（小于）另一方则交换位置，重复的次数为数组的长度 -1次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序(从小到大)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortArr</span> (arr) &#123;</span><br><span class="line">  <span class="comment">// 控制循环多少次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 控制比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// 一次循环中，如果前者大于后者就交换位置，所以第一次循环最大的就在最后</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 要从大到小排序的话，把 &gt; 改为 &lt; 就可以了</span></span><br><span class="line">        <span class="comment">// 交换位置</span></span><br><span class="line">        <span class="keyword">const</span> element = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="title function_">sortArr</span>(arr) <span class="comment">// [2, 3, 6, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p><code>sort()</code> 方法用原地算法对数组的元素进行排序，并返回数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>() <span class="comment">// [10, 2, 3, 6, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，10排在了最前面，这是因为： <strong>sort方法取决于具体实现，因此无法保证排序的时间和空间复杂性。</strong></p>
<p><strong>解决方案</strong><br>封装一个排序函数，然后将该函数当作参数传递给数组的sort方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArr</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m - n <span class="comment">// 从小到大</span></span><br><span class="line">  <span class="keyword">return</span> n - m <span class="comment">// 从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(sortArr)</span><br></pre></td></tr></table></figure>

<h2 id="根据数组里面的时间字符串排序"><a href="#根据数组里面的时间字符串排序" class="headerlink" title="根据数组里面的时间字符串排序"></a>根据数组里面的时间字符串排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123;</span><br><span class="line">  <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;001&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;2021-10-16&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;002&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;2021-11-17&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;003&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;2021-10-10&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;004&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;2021-11-10&#x27;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>方法与sort中的方式相同，唯一的区别就是将时间进行转换然后排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 正序</span></span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的 time 要根据本身的数据来，后面的正则匹配也要根据自己数据来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">parse</span>(a.<span class="property">time</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)) - <span class="title class_">Date</span>.<span class="title function_">parse</span>(b.<span class="property">time</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 倒序</span></span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">parse</span>(b.<span class="property">time</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)) - <span class="title class_">Date</span>.<span class="title function_">parse</span>(a.<span class="property">time</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关文档：<a href="https://blog.csdn.net/qq_41033913/article/details/90754217">https://blog.csdn.net/qq_41033913/article/details/90754217</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的方法</title>
    <url>/2020/12/20/Script/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="整理了一下数组的方法"><a href="#整理了一下数组的方法" class="headerlink" title="整理了一下数组的方法"></a>整理了一下数组的方法</h2><p>1、arr.push() 从后面添加元素，返回值为添加完后的数组的长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">push</span>(<span class="number">5</span>))   <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1,2,3,4,5,5]</span></span><br></pre></td></tr></table></figure>

<p>2、arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">pop</span>())     <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>3、arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">shift</span>())  <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)   <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>4、arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">unshift</span>(<span class="number">2</span>))    <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)  <span class="comment">//[2,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>5、arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素。</p>
<p>参数： i 下标值   n 个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>))     <span class="comment">//[3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)    <span class="comment">// [1,2,5]</span></span><br></pre></td></tr></table></figure>

<p>6、arr.concat() 连接两个数组 返回值为连接后的新数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>([<span class="number">1</span>,<span class="number">2</span>]))  <span class="comment">// [1,2,3,4,5,1,2]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)   <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>7、str.split() 将字符串转化为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)) <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]</span></span><br></pre></td></tr></table></figure>

<p>8、arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sort</span>())   <span class="comment">// [1, 10, 2, 22, 3, 4, 6]</span></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span>a - b)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)   <span class="comment">// [1, 2, 3, 4, 6, 10, 22]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span>b-a)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)  <span class="comment">// [22, 10, 6, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>9、arr.reverse() 将数组反转,返回值是反转后的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reverse</span>())    <span class="comment">// [5,4,3,2,1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)    <span class="comment">// [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<p>10、arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">3</span>))   <span class="comment">// [2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)    <span class="comment">//  [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>11、arr.forEach(callback) 遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组</p>
<p>  callback的参数： value –当前下标的值</p>
<pre><code>              index --下标

              array --原数组
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line">    &#125;)   </span><br><span class="line">    <span class="comment">//  value:1    index:0     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">//  value:2    index:1     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">//  value:3    index:2     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">//  value:4    index:3     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">//  value:5    index:4     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        value = value * <span class="number">2</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line">    &#125;)   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">    <span class="comment">// value:2    index:0     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">// value:4    index:1     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">// value:6    index:2     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">// value:8    index:3     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">// value:10   index:4     array:1,2,3,4,5</span></span><br><span class="line">    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;     </span><br><span class="line"></span><br><span class="line"> arr[index] = item * <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> arr </span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [2,4,6,8]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p>12、arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组 。</p>
<p>  callback的参数： value –当前下标的值</p>
<pre><code>              index --下标

              array --原数组
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">map</span>( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        value = value * <span class="number">2</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line">&#125;)   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = arr1.<span class="title function_">map</span>(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123; </span><br><span class="line"></span><br><span class="line"> item = item * <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> item; </span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// [3,6,9,12]</span></span><br></pre></td></tr></table></figure>

<p>ps: arr.forEach()和arr.map()的区别<br>  \1. arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。<br>  \2. arr.forEach() 没有return arr.map() 有return</p>
<p>13、arr.filter(callback) 过滤数组，返回一个满足要求的数组 </p>
<p>  callback的参数： value –当前下标的值</p>
<pre><code>              index --下标
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">filter</span>( <span class="function">(<span class="params">value, index</span>) =&gt;</span> value&lt;<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)    <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">14、arr.every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture</span><br></pre></td></tr></table></figure>

<p>  callback的参数： value –当前下标的值</p>
<pre><code>              index --下标
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">every</span>( <span class="function">(<span class="params">value, index</span>) =&gt;</span>value&lt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">every</span>( <span class="function">(<span class="params">value, index</span>) =&gt;</span>value&lt;<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>15、arr.some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">some</span>( <span class="function">(<span class="params">value, index</span>) =&gt;</span>value&lt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">some</span>( <span class="function">(<span class="params">value, index</span>) =&gt;</span>value&gt;<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>16、arr.reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值</p>
<p>  参数： callback: prev 必选 –上一次调用回调返回的值，或者是提供的初始值（initialValue）</p>
<pre><code>    next必选 --数组中当前被处理的数组项

    index 可选 --当前数组项在数组中的下标值

    array 可选 --原数组

    initialValue: 可选 --初始值
</code></pre>
<p>  实行方法：回调函数第一次执行时，prev和 next可以是一个值，如果 initialValue 在调用 reduce() 时被提供，那么第一个 prev 等于 initialValue ，并且next等于数组中的第一个值；如果initialValue 未被提供，那么prev 等于数组中的第一个值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> </span><br><span class="line">    prev + next</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>



<p>reduce的高级用法</p>
<p> （1）计算数组中每个元素出现的次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;peter&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;mary&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;peter&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameNum = names.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,next</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cur <span class="keyword">in</span> prev)&#123;</span><br><span class="line"></span><br><span class="line">    prev[next]++</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    prev[next] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameNum); <span class="comment">//&#123; peter: 2, tom: 2, mary: 1, bob: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>  （2）数组去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!prev.<span class="title function_">includes</span>(next))&#123;</span><br><span class="line">      <span class="keyword">return</span> prev.<span class="title function_">concat</span>(next)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>（3）将多维数组转化为一维</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">const</span> newArr = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,next</span>)=&gt;</span>prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)?<span class="title function_">newArr</span>(next):next),[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">newArr</span>(arr)); <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<p>17、arr.reduceRight(callback, initialValue) 与arr.reduce()功能一样，不同的是，reduceRight()从数组的末尾向前将数组中的数组项做累加。</p>
<p>  实行方法：reduceRight()首次调用回调函数callbackfn时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> </span><br><span class="line">    prev + next</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">18、arr.indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1</span><br><span class="line">let arr = [1,2,3,4,5,2]</span><br><span class="line">let arr1 = arr.indexOf(2)</span><br><span class="line">console.log(arr1)  // 1</span><br><span class="line">let arr2 = arr.indexOf(9)</span><br><span class="line">console.log(arr2)  // -1</span><br></pre></td></tr></table></figure>

<p>19、arr.lastIndexOf()  和arr.indexOf()的功能一样，不同的是从后往前查找</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">lastIndexOf</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)  <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">lastIndexOf</span>(<span class="number">9</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>20 、Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(str))    <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="number">0</span>:<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>,<span class="attr">length</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(obj))   <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>21、Array.of() 将一组值转换成数组，类似于声明数组  —es6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;11&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(str))   <span class="comment">// [&#x27;11&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;11&#x27;</span>))  <span class="comment">// [&#x27;11]</span></span><br></pre></td></tr></table></figure>

<p>22、arr.copyWithin() 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组</p>
<p>  参数: target –必选 下标从该位置开始替换数组项</p>
<pre><code>    start --可选 下标从该位置开始读取数组项，默认为0.如果为负值，则从右往左读。

    end --可选 下标到该位置停止读取的数组项，默认是Array.length,如果是负值，表示倒数
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">copyWithin</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)   <span class="comment">// [1, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">copyWithin</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)   <span class="comment">// [1, 3, 4, 5, 6, 7, 7]</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.<span class="title function_">copyWithin</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)   <span class="comment">// [1, 3, 4, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<p>23、arr.find(callback) 找到第一个符合条件的数组成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">find</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>value &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>24、arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> value &gt; <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>25、arr.fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组</p>
<p>  参数： target – 待填充的元素</p>
<pre><code>    start -- 开始填充的位置-下标

    end -- 终止填充的位置-下标（不包括该位置)
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">fill</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)  <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)   <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">fill</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.<span class="title function_">fill</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)</span><br></pre></td></tr></table></figure>

<p>26、arr.includes() 判断数中是否包含给定的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">includes</span>(<span class="number">2</span>)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)   <span class="comment">// ture</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">includes</span>(<span class="number">9</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)    <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与indexOf()的区别：</p>
<p>1 indexOf()返回的是数值，而includes()返回的是布尔值</p>
<p>2 indexOf() 不能判断NaN，返回为-1 ，includes()则可以判断</p>
<p>27、arr.keys() 遍历数组的键名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">keys</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr2) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);   <span class="comment">// 0,1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28、arr.values() 遍历数组键值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">values</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(val);   <span class="comment">// 1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29、arr.entries() 遍历数组的键名和键值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">entries</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);   <span class="comment">// [0,1] [1,2] [2,3] [3,4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entries() 方法返回迭代数组。</p>
<p>迭代数组中每个值 前一个是索引值作为 key， 数组后一个值作为 value。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>柯里化函数</title>
    <url>/2021/03/10/Script/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="柯里化函数的概念"><a href="#柯里化函数的概念" class="headerlink" title="柯里化函数的概念"></a><strong>柯里化函数的概念</strong></h3><ol>
<li>什么是柯里化函数？</li>
</ol>
<p>​         柯里化是把接收多个参数的函数变成接受一个单一参数，返回接受余下的参数且返回结果的新函数。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingadd</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)		  <span class="comment">// return 3</span></span><br><span class="line"><span class="title function_">curryingadd</span>(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// return 3</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为什么要使用柯里化函数 参数复用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">peach</span>(<span class="params">name, time, event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我<span class="subst">$&#123;name&#125;</span>于<span class="subst">$&#123;time&#125;</span>与两位兄弟<span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">peach</span>(<span class="string">&#x27;刘备&#x27;</span>, <span class="string">&#x27;今日&#x27;</span>, <span class="string">&#x27;桃园结义&#x27;</span>) <span class="comment">// 我刘备于今日与两位兄弟桃园结义</span></span><br><span class="line"><span class="title function_">peach</span>(<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;今日&#x27;</span>, <span class="string">&#x27;桃园结义&#x27;</span>) <span class="comment">// 我关羽于今日与两位兄弟桃园结义</span></span><br><span class="line"><span class="title function_">peach</span>(<span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;今日&#x27;</span>, <span class="string">&#x27;桃园结义&#x27;</span>) <span class="comment">// 我张飞于今日与两位兄弟桃园结义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sworn</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我<span class="subst">$&#123;name&#125;</span>于<span class="subst">$&#123;time&#125;</span>与两位兄弟<span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Info</span> = <span class="title function_">sworn</span>(<span class="string">&#x27;今日&#x27;</span>)(<span class="string">&#x27;桃园结义&#x27;</span>)</span><br><span class="line"><span class="title class_">Info</span>(<span class="string">&#x27;刘备&#x27;</span>) <span class="comment">// 我刘备于今日与两位兄弟桃园结义</span></span><br><span class="line"><span class="title class_">Info</span>(<span class="string">&#x27;关羽&#x27;</span>) <span class="comment">// 我关羽于今日与两位兄弟桃园结义</span></span><br><span class="line"><span class="title class_">Info</span>(<span class="string">&#x27;张飞&#x27;</span>) <span class="comment">// 我张飞于今日与两位兄弟桃园结义</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现一个add方法，使结算结果满足预期结果</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add(1)(2)(3) == 6;</span></span><br><span class="line"><span class="comment">// add(1, 2, 3)(4) == 10;</span></span><br><span class="line"><span class="comment">// add(1)(2)(3)(4)(5) == 15;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        _args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _args.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))       <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>))    <span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)) <span class="comment">//15</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>柯里化函数</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>JavaScript</tag>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/01/26/Script/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>观察者模式 ( Observer mode ) 指的是函数自动观察数据对象，当数据对象发生改变，函数会自动执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">observer</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行：李四， 20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数据对象 <code>person</code> 是观察对象，函数 <code>print</code> 是观察者。当数据对象 <code>person</code> 发生变化， <code>print</code> 就会自动执行。</p>
<p>使用 Proxy 写一个观察者模式的最简单实现，即实现 <code>observable</code> 和<code>observe</code> 这两个函数。思路是 <code>observable</code> 函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的两个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = (<span class="params">fn</span>) =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; set &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receive);</span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先定义了一个 <code>Set</code> 集合，所有观察者函数都放进这个集合。<code>observable</code> 函数返回原始对象的代理，拦截赋值操作。拦截函数 <code>set</code> 中会自动执行的所有观察者。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>codeMirror封装</title>
    <url>/2022/12/19/components/codemirror/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="vue2使用-codeMirror"><a href="#vue2使用-codeMirror" class="headerlink" title="vue2使用 codeMirror"></a>vue2使用 codeMirror</h1><p>vue3的版本叫vue-codemirror，vue2的版本叫codemirror。<br>使用 vue2 得指定版本号，不指定就是默认最新，版本6以上都是vue3的版本，引入使用会报错。</p>
<h2 id="安装-codeMirror"><a href="#安装-codeMirror" class="headerlink" title="安装 codeMirror"></a>安装 codeMirror</h2><p>我这里使用的5.46.0版本的，vue2.7，如果各位小伙伴5.46.0的版本不支持就安装5以下版本吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add codemirror@<span class="number">5.46</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// or npm install codemirror@5.46.0</span></span><br></pre></td></tr></table></figure>

<h2 id="封装-codeMirror-组件"><a href="#封装-codeMirror-组件" class="headerlink" title="封装 codeMirror 组件"></a>封装 codeMirror 组件</h2><p>主题请参考官网CodeMirror: Theme Demo，注意：使用主题前记得引入哦（主题位置有注释）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;common-editor&quot;&gt;</span><br><span class="line">    &lt;textarea ref=&quot;textarea&quot; v-model=&quot;value&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#x27;codemirror/lib/codemirror.css&#x27;</span><br><span class="line">import &#x27;codemirror/theme/darcula.css&#x27; // codeMirror 主题</span><br><span class="line">import &#x27;codemirror/addon/hint/show-hint.css&#x27;</span><br><span class="line">import &#x27;codemirror/addon/hint/show-hint.js&#x27;</span><br><span class="line">import &#x27;codemirror/addon/hint/show-hint&#x27;</span><br><span class="line">import &#x27;codemirror/addon/hint/javascript-hint&#x27;</span><br><span class="line">import &#x27;codemirror/addon/hint/sql-hint&#x27;</span><br><span class="line">import &#x27;codemirror/mode/javascript/javascript&#x27;</span><br><span class="line">// 以下为 codeMirror 支持的语言，下面只展示了一部分，各位小伙伴可以自行添加</span><br><span class="line">import &#x27;codemirror/mode/markdown/markdown&#x27;</span><br><span class="line">import &#x27;codemirror/mode/sql/sql&#x27;</span><br><span class="line">import &#x27;codemirror/mode/php/php&#x27;</span><br><span class="line">import &#x27;codemirror/mode/python/python&#x27;</span><br><span class="line">import &#x27;codemirror/mode/shell/shell&#x27;</span><br><span class="line">import &#x27;codemirror/mode/powershell/powershell&#x27;</span><br><span class="line">import &#x27;codemirror/mode/yaml/yaml.js&#x27;</span><br><span class="line"> </span><br><span class="line">const CodeMirror = require(&#x27;codemirror/lib/codemirror&#x27;)</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;CodeMirror&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    language: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      CommonEditor: false,</span><br><span class="line">      code: &#x27;&#x27;,</span><br><span class="line">      coder: null,</span><br><span class="line">      mode: &#x27;javascript&#x27;,</span><br><span class="line">      theme: &#x27;default&#x27;,</span><br><span class="line">      modes: [</span><br><span class="line">        &#123; value: &#x27;javascript&#x27;, label: &#x27;Javascript&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-java&#x27;, label: &#x27;Java&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-python&#x27;, label: &#x27;Python&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-sql&#x27;, label: &#x27;SQL&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-shell&#x27;, label: &#x27;Shell&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-powershell&#x27;, label: &#x27;PowerShell&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-php&#x27;, label: &#x27;PHP&#x27; &#125;,</span><br><span class="line">        &#123; value: &#x27;x-yaml&#x27;, label: &#x27;Yaml&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">      coderOptions: &#123;</span><br><span class="line">        line: true,</span><br><span class="line">        mode: &#x27;yaml&#x27;, // json数据高亮</span><br><span class="line">        theme: &#x27;darcula&#x27;, // 设置主题 记得引入对应主题才有显示   import &#x27;codemirror/theme/blackboard.css&#x27;</span><br><span class="line">        tabSize: 1,</span><br><span class="line">        readOnly: &#x27;&#x27;,</span><br><span class="line">        lineNumbers: true, // 显示行号</span><br><span class="line">        cursorHeight: 0.8, // 光标高度，默认是1</span><br><span class="line">        autoCloseBrackets: true,</span><br><span class="line">        matchBrackets: true, // 括号匹配</span><br><span class="line">        lineWrapping: &#x27;wrap&#x27;, // 文字过长时，是换行(wrap)还是滚动(scroll),默认是滚动</span><br><span class="line">        showCursorWhenSelecting: true, // 文本选中时显示光标</span><br><span class="line">        smartIndent: true, // 智能缩进</span><br><span class="line">        completeSingle: false // 当匹配只有一项的时候是否自动补全</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    language: &#123;</span><br><span class="line">      handler(language) &#123;</span><br><span class="line">        this.getCoder().then(() =&gt; &#123;</span><br><span class="line">          // 尝试从父容器获取语法类型</span><br><span class="line">          if (language) &#123;</span><br><span class="line">            // 获取具体的语法类型对象</span><br><span class="line">            const modeObj = this.getLanguage(language)</span><br><span class="line">            // 判断父容器传入的语法是否被支持</span><br><span class="line">            if (modeObj) &#123;</span><br><span class="line">              this.mode = modeObj.label</span><br><span class="line">              this.coder.setOption(&#x27;mode&#x27;, `text/$&#123;modeObj.value&#125;`)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    this.initialize()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    initialize() &#123;</span><br><span class="line">      // 初始化编辑器实例，传入需要被实例化的文本域对象和默认配置</span><br><span class="line">      this.coder = CodeMirror.fromTextArea(</span><br><span class="line">        this.$refs.textarea,</span><br><span class="line">        this.coderOptions</span><br><span class="line">      )</span><br><span class="line">      this.coder.on(&#x27;inputRead&#x27;, () =&gt; &#123;</span><br><span class="line">        this.coder.showHint()</span><br><span class="line">      &#125;)</span><br><span class="line">      // 编辑器赋值</span><br><span class="line">      if (this.value || this.code) &#123;</span><br><span class="line">        this.setCodeContent(this.value || this.code)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.coder.setValue(&#x27;&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      // 支持双向绑定</span><br><span class="line">      this.coder.on(&#x27;change&#x27;, (coder) =&gt; &#123;</span><br><span class="line">        this.code = coder.getValue()</span><br><span class="line">        if (this.$emit) &#123;</span><br><span class="line">          this.$emit(&#x27;input&#x27;, this.code)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    setCodeContent(val) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">          this.coder.setValue(&#x27;&#x27;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.coder.setValue(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 300)</span><br><span class="line">    &#125;,</span><br><span class="line">    getCoder() &#123;</span><br><span class="line">      const that = this</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">        (function get() &#123;</span><br><span class="line">          if (that.coder) &#123;</span><br><span class="line">            resolve(that.coder)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            setTimeout(get, 10)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getLanguage(language) &#123;</span><br><span class="line">      // 在支持的语法类型列表中寻找传入的语法类型</span><br><span class="line">      return this.modes.find((mode) =&gt; &#123;</span><br><span class="line">        // 所有的值都忽略大小写，方便比较</span><br><span class="line">        const currentLanguage = language.toLowerCase()</span><br><span class="line">        const currentLabel = mode.label.toLowerCase()</span><br><span class="line">        const currentValue = mode.value.toLowerCase()</span><br><span class="line"> </span><br><span class="line">        // 由于真实值可能不规范，例如 java 的真实值是 x-java ，所以讲 value 和 label 同时和传入语法进行比较</span><br><span class="line">        return (</span><br><span class="line">          currentLabel === currentLanguage || currentValue === currentLanguage</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    changeMode(val) &#123;</span><br><span class="line">      // 修改编辑器的语法配置</span><br><span class="line">      this.coder.setOption(&#x27;mode&#x27;, `text/$&#123;val&#125;`)</span><br><span class="line">      // 获取修改后的语法</span><br><span class="line">      const label = this.getLanguage(val).label.toLowerCase()</span><br><span class="line">      // 允许父容器通过以下函数监听当前的语法值</span><br><span class="line">      this.$emit(&#x27;language-change&#x27;, label)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">.common-editor &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  .CodeMirror &#123;</span><br><span class="line">    // color: #ccc;</span><br><span class="line">    direction: ltr;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    // background-color: #000;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  .CodeMirror-hints &#123;</span><br><span class="line">    z-index: 9999 !important;</span><br><span class="line">  &#125;</span><br><span class="line">  .custom-class .CodeMirror &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.CodeMirror-hints &#123;</span><br><span class="line">  z-index: 1000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;code-mirror</span><br><span class="line">      :value=&quot;codeContent.codetext&quot;</span><br><span class="line">      language=&quot;sql&quot;</span><br><span class="line">      @input=&quot;changeTextarea&quot;</span><br><span class="line">      style=&quot;height:80vh&quot;</span><br><span class="line">    &gt;&lt;/code-mirror&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import CodeMirror from &#x27;@/components/codeMirror.vue&#x27;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; CodeMirror &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      codeContent: &#123;</span><br><span class="line">        codetext: &#x27;select * from Data&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // codeMirror 双向绑定</span><br><span class="line">    changeTextarea(val) &#123;</span><br><span class="line">      this.codeContent.codetext = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>不以by小经验</tag>
        <tag>codeMirror</tag>
      </tags>
  </entry>
  <entry>
    <title>上传文件</title>
    <url>/2021/09/03/course/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="input-file"><a href="#input-file" class="headerlink" title="input = file"></a>input = file</h2><p>通过 input = file 进行文件上传，上传的文件为图片时展示出图片，为其他格式时，展示上传的文件名</p>
<!-- ![未上传](https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/upload_Image_File/1.png)
![上传后效果](https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/upload_Image_File/2.png) -->
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/upload_Image_File/4.png" alt="上传对比" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;logo&quot; prop=&quot;logo_url&quot;&gt;</span><br><span class="line">      &lt;label :for=&quot;&#x27;uploadImage&#x27;&quot; class=&quot;firstImg el-button el-button--danger el-button--mini&quot;&gt;</span><br><span class="line">        &lt;input :id=&quot;&#x27;uploadImage&#x27;&quot; type=&quot;file&quot; :name=&quot;&#x27;uploadImage&#x27;&quot; style=&quot;display:none&quot; @change=&quot;uploadImage($event, temp)&quot;&gt;</span><br><span class="line">        &lt;!-- input 的 type 属性设置为file, 参数 temp 是提交表单是要提交的值 --&gt;</span><br><span class="line">        &lt;img v-show=&quot;temp.logo_url !== &#x27;&#x27;&quot; :src=&quot;temp.logo_url&quot; class=&quot;firstImg el-button--mini&quot;&gt;</span><br><span class="line">        &lt;!-- v-show=&quot;temp.logo_url !== &#x27;&#x27;&quot; 对 temp 中的 logo_url 属性进行判断,当有值时说明上传了图片,则在页面上显示,否则显示上传 --&gt;</span><br><span class="line">        &lt;div v-show=&quot;temp.logo_url !== &#x27;&#x27;&quot; class=&quot;avatar&quot; /&gt;</span><br><span class="line">        &lt;i class=&quot;el-icon-plus&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-form-item label=&quot;武器&quot; prop=&quot;armory_url&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;temp.armory_url&quot; style=&quot;max-width: 330px;&quot; readonly /&gt;</span><br><span class="line">      &lt;label :for=&quot;&#x27;file&#x27;&quot; class=&quot;el-button el-button--danger el-button--mini&quot;&gt;</span><br><span class="line">        &lt;input :id=&quot;&#x27;file&#x27;&quot; type=&quot;file&quot; :name=&quot;&#x27;file&#x27;&quot; style=&quot;display:none&quot; @change=&quot;FileChange($event, temp)&quot;&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">          上传武器</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        uploadImage(e, row) &#123;</span><br><span class="line">          if (e.target.files.length) &#123;</span><br><span class="line">            var fileReader = new FileReader()</span><br><span class="line">            fileReader.readAsDataURL(e.target.files[0])</span><br><span class="line">            if (e.target.files[0].size &gt; 200 * 1024) &#123;</span><br><span class="line">              // 判断上传的文件大小</span><br><span class="line">              this.$notify(&#123;</span><br><span class="line">                title: &#x27;error&#x27;,</span><br><span class="line">                message: &#x27;请选择小于200KB的图片&#x27;,</span><br><span class="line">                type: &#x27;error&#x27;,</span><br><span class="line">                duration: 2000</span><br><span class="line">              &#125;)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(e.target.files[0])</span><br><span class="line">            fileReader.onload = () =&gt; &#123;</span><br><span class="line">              row.logo_url = fileReader.result</span><br><span class="line">              // 给 temp 中的 logo_url 属性赋值</span><br><span class="line">              this.$notify(&#123;</span><br><span class="line">                title: &#x27;Success&#x27;,</span><br><span class="line">                message: &#x27;上传成功&#x27;,</span><br><span class="line">                type: &#x27;success&#x27;,</span><br><span class="line">                duration: 2000</span><br><span class="line">              &#125;)</span><br><span class="line">              e.target.value = &#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        FileChange(e, row) &#123;</span><br><span class="line">          const input = e.target</span><br><span class="line">          const files = e.target.files</span><br><span class="line">          if (files &amp;&amp; files[0]) &#123;</span><br><span class="line">            const file = files[0]</span><br><span class="line">            if (file.size &gt; 1024 * 1024 * 3) &#123;</span><br><span class="line">              // 判断上传的文件大小</span><br><span class="line">              this.$notify(&#123;</span><br><span class="line">                title: &#x27;error&#x27;,</span><br><span class="line">                message: &#x27;文件大小不能超过3M&#x27;,</span><br><span class="line">                type: &#x27;error&#x27;,</span><br><span class="line">                duration: 2000</span><br><span class="line">              &#125;)</span><br><span class="line">              input.value = &#x27;&#x27;</span><br><span class="line">              return false</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              row.armory_url = file.name</span><br><span class="line">              // 给 temp 中的 armory_url 属性赋值，file.name 是上传的文件名，可另外定义一个值用来展示</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>因为涉及文件上传，表单的 提交必须采起非编码格式 即： <code>&#123; &#39;content-type&#39;: &#39;multipart/form-data;boundary=$&#123;boundary&#125;&#39; &#125;</code><br><code>$&#123;boundary&#125;</code> 为分割字符串。但无论是 <code>fetch、 ajax</code> 只要主动设置 <code>content-type</code> 为 <code>multipart/form-data</code>，不加后面的 <code>boundary</code>，会自动加到传输的格式中，致使后端取不到值。若是加了 <code>boundary</code>，又致使直接 <code>formData</code> 都取不到值。<br>最终解决方案就是，<code>content-type</code> 不进行设置，只将 data 改成 <code>formData</code> 格式。浏览器会自动识别，自动设置为<code>content-type: multipart/form-data;boundary=随机值</code> 的形式。最终上传成功。</p>
<p>可以在 api.js 文件中进行配置请求头参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFile</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/create&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">data</span>: <span class="title function_">searchParams</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="上传按钮鼠标浮动样式"><a href="#上传按钮鼠标浮动样式" class="headerlink" title="上传按钮鼠标浮动样式"></a>上传按钮鼠标浮动样式</h2><p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/upload_Image_File/5.png?raw=true" alt="鼠标浮动样式" loading="lazy"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">  <span class="comment">/* 蒙层，通过定位固定位置在图片上 */</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">148px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">148px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.avatar</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 蒙层，鼠标浮动在图片上时展示 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.firstImg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">148px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">148px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#c0ccda</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-icon-plus</span> &#123;</span><br><span class="line">  <span class="comment">/* 上传图片中的 icon 图标 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#8c939d</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">148px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.firstImg</span><span class="selector-class">.el-button--danger</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标浮动在图片上时添加 box-shadow 属性 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#c0ccda</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>:</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">0</span> <span class="built_in">rgb</span>(<span class="number">232</span> <span class="number">237</span> <span class="number">250</span> / <span class="number">60%</span>),</span><br><span class="line">    <span class="number">0</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">0</span> <span class="built_in">rgb</span>(<span class="number">232</span> <span class="number">237</span> <span class="number">250</span> / <span class="number">50%</span>);</span><br><span class="line">  <span class="selector-class">.el-icon-plus</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="comment">/* 鼠标浮动时图标位置 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">50%</span>,-<span class="number">50%</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.firstImg</span><span class="selector-class">.el-button--mini</span> &#123;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">/* 去掉属性的默认样式，如有全局配置可忽略 */</span></span><br></pre></td></tr></table></figure>

<p>参考文档：<br><code>input = file</code> <a href="https://blog.csdn.net/liwenfei123/article/details/94453335">https://blog.csdn.net/liwenfei123/article/details/94453335</a><br><code>content-type: multipart/form-data;</code> <a href="https://www.shangmayuan.com/a/e52e952d2229449b9a3dca6a.html">https://www.shangmayuan.com/a/e52e952d2229449b9a3dca6a.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>File</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>JavaScript</tag>
        <tag>上传文件</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>下载文件</title>
    <url>/2021/09/03/course/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="静态文件下载"><a href="#静态文件下载" class="headerlink" title="静态文件下载"></a>静态文件下载</h2><h3 id="第1种：使用-a-标签下载"><a href="#第1种：使用-a-标签下载" class="headerlink" title="第1种：使用 a 标签下载"></a>第1种：使用 a 标签下载</h3><p>html中的a标签自带静态下载</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">download</span>=<span class="string">&quot;aaa.txt&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./data-mock/aaa.txt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>download 中的内容是要下载的文件名<br>href 中的路径要根据 index.html 来写，否则可能会提示： 失败未发现文件</p>
<h3 id="第2种：创建一个点击事件"><a href="#第2种：创建一个点击事件" class="headerlink" title="第2种：创建一个点击事件"></a>第2种：创建一个点击事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;help-center&quot; name=&quot;downloadFile&quot; @click=&quot;downloadClick&quot;&gt;下载模板&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    downloadClick() &#123;</span><br><span class="line">      var link = document.createElement(&#x27;a&#x27;)</span><br><span class="line">      link.setAttribute(&#x27;download&#x27;, &#x27;&#x27;)</span><br><span class="line">      link.href = &#x27;./模板.zip&#x27;</span><br><span class="line">      link.click()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="从后端获取接口下载"><a href="#从后端获取接口下载" class="headerlink" title="从后端获取接口下载"></a>从后端获取接口下载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-button type=&quot;warning&quot; size=&quot;mini&quot; @click=&quot;handleExport(row)&quot;&gt;下载文件&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleExport(row) &#123;</span><br><span class="line">      // 根据接口需要添加 id</span><br><span class="line">      fetch(`/api/$&#123;row.id&#125;/download`, &#123;</span><br><span class="line">        headers: &#123; &#x27;TOKEN&#x27;: token, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;</span><br><span class="line">        // 设置请求头和 token</span><br><span class="line">      &#125;).then(v =&gt; &#123;</span><br><span class="line">        // 通过 blob() 读取返回的数据，并进行判断</span><br><span class="line">        v.blob().then(val =&gt; &#123;</span><br><span class="line">          // 判断返回的值中 type 属性是否能找到 &#x27;text/html&#x27; 或 &#x27;text/plain&#x27;，具体返回什么需要根据下载的文件判断，火狐浏览器和谷歌浏览器返回的值不同</span><br><span class="line">          if (val.type.indexOf(&#x27;text/html&#x27;) !== -1 || val.type.indexOf(&#x27;text/plain&#x27;) !== -1) &#123;</span><br><span class="line">            // 返回值不等于 -1 说明查找到了，创建一个 a 标签，下载方法同 静态下载中的 a 标签</span><br><span class="line">            var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">            a.download = &#x27;下载文件.&#x27; + type</span><br><span class="line">            a.href = URL.createObjectURL(val)</span><br><span class="line">            document.body.appendChild(a)</span><br><span class="line">            a.click()</span><br><span class="line">            document.body.removeChild(a)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 下载失败提示</span><br><span class="line">            this.$message(&#123;</span><br><span class="line">              title: &#x27;Error&#x27;,</span><br><span class="line">              message: &#x27;下载失败&#x27;,</span><br><span class="line">              type: &#x27;error&#x27;,</span><br><span class="line">              duration: 2000</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>参考文档：<br>静态下载 <a href="https://blog.csdn.net/github_39096247/article/details/108365018">https://blog.csdn.net/github_39096247/article/details/108365018</a><br>获取接口 <a href="https://www.cnblogs.com/ldlx-mars/p/10647091.html">https://www.cnblogs.com/ldlx-mars/p/10647091.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>File</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>JavaScript</tag>
        <tag>File</tag>
        <tag>下载文件</tag>
      </tags>
  </entry>
  <entry>
    <title>判断字符串是否为 JSON 格式</title>
    <url>/2021/11/22/course/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BAJSON%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>在字符串使用中数据可能是 JSON 字符串，也可能是普通字符串，而这个时候需要进行判断，当为 JSON 字符串时需要进行转换才能使用<br>当字符串不是 JSON 格式时，直接使用 <code>JSON.parse()</code> 进行转换会导致报错 <code>Uncaught SyntaxError: Unexpected token a in JSON at position 0</code>,所以需要判断字符串是否为JSON格式，再根据返回的结果转换</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">isJSON</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str)</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关文档：<a href="https://www.cnblogs.com/lanleiming/p/7096973.html">https://www.cnblogs.com/lanleiming/p/7096973.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>图片跨域</title>
    <url>/2021/09/05/course/%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>图片跨域<br>在 <code>index.html</code> 的 <code>&lt;title&gt;&lt;/title&gt;</code> 标签中加上 <code>&lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;</code> 就可以了</p>
]]></content>
      <tags>
        <tag>不以by小经验</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>图片预览</title>
    <url>/2021/12/10/course/%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>点击预览图片全屏展示图片，背景添加蒙层，再次点击图片返回<br>组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 过渡动画 --&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;img-view&quot; @click=&quot;closePreview&quot;&gt;</span><br><span class="line">      &lt;img :src=&quot;imgSrc&quot; alt=&quot;加载失败&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;imgSrc&#x27;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    closePreview () &#123;</span><br><span class="line">      // 发送事件</span><br><span class="line">      this.$emit(&#x27;clickPreview&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">/*动画*/</span><br><span class="line">.fade-enter-active,</span><br><span class="line">.fade-leave-active &#123;</span><br><span class="line">  transition: all 0.2s linear;</span><br><span class="line">  transform: translate3D(0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter,</span><br><span class="line">.fade-leave-active &#123;</span><br><span class="line">  transform: translate3D(100%, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">/* Preview */</span><br><span class="line">.img-view &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  z-index: 9999;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background: rgba(0, 0, 0, 0.7);</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">/*不限制图片大小，实现居中*/</span><br><span class="line">.img-view img &#123;</span><br><span class="line">  width: 800px;</span><br><span class="line">  display: block;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translateX(-50%) translateY(-50%);</span><br><span class="line">  z-index: 10000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img</span><br><span class="line">    :src=&quot;imgSrc&quot;</span><br><span class="line">    title=&quot;图片&quot;</span><br><span class="line">    style=&quot;width:102px;margin-right:10px;&quot;</span><br><span class="line">    @click=&quot;clickImg(imgSrc)&quot;</span><br><span class="line">  &gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 图片放大组件 --&gt;</span><br><span class="line">  &lt;preview v-if=&quot;showImg&quot; @clickPreview=&quot;closePreview&quot; :imgSrc=&quot;imgSrc&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Preview from &#x27;@/components/Preview&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; Preview &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    // 图片放大控制数据</span><br><span class="line">      showImg: false,</span><br><span class="line">      imgSrc: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 图片放大控制事件</span><br><span class="line">    clickImg (imgSrc) &#123;</span><br><span class="line">      if (imgSrc) &#123;</span><br><span class="line">        this.imgSrc = imgSrc</span><br><span class="line">        this.showImg = true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 关闭事件</span><br><span class="line">    closePreview () &#123;</span><br><span class="line">      this.imgSrc = &#x27;&#x27;</span><br><span class="line">      this.showImg = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>相关文档：<a href="https://blog.csdn.net/weixin_45031595/article/details/112269851">https://blog.csdn.net/weixin_45031595/article/details/112269851</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>不以by小经验</tag>
        <tag>图片预览</tag>
      </tags>
  </entry>
  <entry>
    <title>防御式编程</title>
    <url>/2021/12/16/course/%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="什么是防御性编程"><a href="#什么是防御性编程" class="headerlink" title="什么是防御性编程"></a>什么是防御性编程</h1><p>相关文档：<a href="https://xie.infoq.cn/article/9bbd384642d0f6ca171a91231">https://xie.infoq.cn/article/9bbd384642d0f6ca171a91231</a></p>
<p>防御型编程是一种细致、谨慎的编程方法。为了开发可靠软件，我们要设计系统中的每个组件，使其尽可能<strong>保护</strong>自己。我们通过对代码的设想进行检查，防止我们的代码以将会展现错误行为的方式被调用。</p>
<p>防御型编程使我们可以尽早发现较小的问题，而不是等到发展成大灾难时才被发现。</p>
<p>以往的开发过程： 编写 =&gt; 测试 =&gt; 发现问题 =&gt; 编写 =&gt; 测试 =&gt; 发现问题 =&gt; ……</p>
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/course/06095414-e6d04d57a95d42eb8838ca9211d5fc01.jpg" alt="以往的开发过程" loading="lazy"></p>
<p>防御性编程开发过程： 编写 =&gt; 测试 =&gt; 成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/course/06095525-64903243094d4edda9d9d1bc1cf96cf6.jpg" alt="防御性编程开发过程" loading="lazy"></p>
<p>防御式编程帮助我们从一开始就编写正确的代码，不再需要经历“ 编写 =&gt; 测试 =&gt; 发现问题 =&gt; 编写 =&gt; 测试 =&gt; 发现问题 =&gt; ……”的循环。</p>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p>
<ol>
<li>节省大量调试时间</li>
<li>避免了大量安全性问题</li>
<li>编写可以正常运行、只是速度有些慢的代码，要远远好过大多数时间都正常运行、但有时会崩溃的代码</li>
</ol>
<p>缺点：</p>
<ol>
<li>降低了代码效率，即使一个很小的代码也需要一些额外的时间执行。对于一个函数来说也许不要紧，但有多个函数组成的系统，问题就变得严重了</li>
<li>每种防御性的做法都需要一些额外的工作</li>
</ol>
<p>防御性编程不能排除所有错误，但可以减少问题带来的麻烦，并易于修改。</p>
<blockquote>
<p>防御性编程是一种防卫方式，而不是一种补救方式。</p>
</blockquote>
<h1 id="防御式编程技巧"><a href="#防御式编程技巧" class="headerlink" title="防御式编程技巧"></a>防御式编程技巧</h1><p>相关文档：<a href="https://blog.csdn.net/everpenny/article/details/6316698">https://blog.csdn.net/everpenny/article/details/6316698</a></p>
<ol>
<li><p>使用好的编码风格和合理的设计</p>
<p>采用良好的编码风格来防范大多数编码错误，如：使用有意义的变量名。可以使编码更加清晰明了，减少缺陷出现的可能性。</p>
</li>
<li><p>不要仓促地编写代码</p>
<p>每敲一行代码都要三思而后行，要先想好可能会出现什么错误？是否考虑了所有可能出现的逻辑分支？有条不紊的编程虽然看上去很平凡，但确是减少缺陷的好办法。</p>
</li>
<li><p>不要相信任何外部输入的参数</p>
<p>不要相信任何输入的值和结果，因为使用者可能是任何人，可能没有阅读过相关手册，他们会输入任何意想不到的参数。所以需要对所有输入的参数进行合法性的检查，发现问题立即终止函数，返回预设的错误值。</p>
</li>
<li><p>不要忽略任何一个错误</p>
<p>代码产生任何警告信息都应立即修正。出现警告总是有原因的，即使你认为某个警告无关紧要，也不要置之不理。</p>
</li>
<li><p>不要假定异常不会发生</p>
<p>异常不是错误，错误时可预期的，也是经常会发生的，我们有对应的错误与处理方案，但异常确是少见的、意料之外的。</p>
<p>虽然异常发生是“小众事件”，但我们不能假定异常不会发生。所以在编写代码时，需要考虑代码是否要设置异常捕捉和恢复。</p>
</li>
<li><p>编码的目标是清晰，不是简洁</p>
<p>不要让代码过于复杂。编写的代码一定要逻辑清晰，可读性强。多对数据进行判断，当多个数据进行相似判断时可封装模块进行判断。</p>
</li>
<li><p>使用安全的数据结构</p>
<p>代码中的一部分安全隐患是由于不正确的使用固定大小的数据结构造成的。</p>
</li>
<li><p>检查所有返回值</p>
<p>但函数返回一个值一定是有理由的，但同时也要检查返回值，如果返回值是一段错误代码，就必须辨别这个代码并处理所有的错误。</p>
<p>例如需要返回的数据需要 <code>id</code>, <code>name</code>, <code>age</code> 三个数据都不能为空才会存入 <code>data</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  	<span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张四&#x27;</span>,</span><br><span class="line">  	<span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  	<span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>当其中一个数据为空时就会造成问题，我们可以在数据存入 <code>data</code> 之前进行判断，如果参数有一个为空就不存入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = []</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!item.<span class="property">id</span> &amp;&amp; !item.<span class="property">name</span> &amp;&amp; !item.<span class="property">age</span>) <span class="keyword">return</span></span><br><span class="line">    data.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>审慎的处理内存</p>
<p>对于在执行期间获取的任何资源，必须彻底释放。例如：创建页面后添加的定时器，在销毁页面是也需要销毁定时器。</p>
</li>
<li><p>在使用变量前初始化变量</p>
<p>变量声明但不关注初始值可能会引发后续的问题。例如下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getList() &#123;</span><br><span class="line">            const arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]</span><br><span class="line">            arr.forEach(item =&gt; &#123;</span><br><span class="line">                list.push(&#123; name: item &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>因为没有在调用方法四对数据进行初始化，再次调用 <code>getList</code> 方法时就会出现这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">list</span>: [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>所以在使用变量前要及时初始化。</p>
</li>
<li><p>平时编码时还需要注意到一些细节：</p>
<ol>
<li>检查数值的上下限：确保每次运算数值变量都不会溢出，数据类型的使用要谨慎</li>
<li>注意强制转换是否合理</li>
<li>声明变量时，声明位置与使用位置尽量接近，防止干扰代码其他部分</li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>想要做好防御式编程，我们往往需要花3倍以上的时间去处理（数据流的处理，思考代码严谨性、思考信息提示、思考代码走向……）。<br>如果你想快速开发出高质量模块，不仅需要经验的积累，培养防御型编程的思维必不可少。</p>
<h2 id="优秀的程序应该做到："><a href="#优秀的程序应该做到：" class="headerlink" title="优秀的程序应该做到："></a>优秀的程序应该做到：</h2><ul>
<li>关心代码是否健壮</li>
<li>确保每个设想都显示地体现在防御性代码中</li>
<li>希望代码对无用信息的输入有正确的行为</li>
<li>在编程的时候认真思考自己所编写的代码</li>
<li>编写可以保护自己不受其他人的愚蠢伤害的代码。</li>
</ul>
]]></content>
      <tags>
        <tag>不以by小经验</tag>
        <tag>防御式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流封装</title>
    <url>/2021/09/02/course/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p>一定时间内仅执行一次，如果未到截止时间再次触发，则重新计算（也就是说如果一直不停的触发，那么这个函数一直不会执行，直到停止触发并且到了时间才会被执行）<br>应用场景：登录点击</p>
<h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>一定时间内仅执行一次，如果未到截止时间再次触发，则触发不会生效（也就是说如果一直不停的触发，也只会每固定时间间隔执行一次，在时间范围内无法触发事件）<br>应用场景：搜索框输入即时搜索</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>首先在 src/utils 文件夹下创建 utils.js 文件</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 防抖节流函数 */</span></span><br><span class="line"><span class="keyword">let</span> timeout = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line"><span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖,用于搜索框搜索</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout) <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, <span class="number">1500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流,用于提交</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span></span><br><span class="line">    canRun = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      canRun = <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure>

<p>在 main.js 全局引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">&#x27;../common/utils.js&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(utils) <span class="comment">// 引用这个utils</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$utils</span> = utils <span class="comment">// 全局请求方法</span></span><br></pre></td></tr></table></figure>


<p>调用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$utils.throttle(() =&gt; &#123;</span><br><span class="line">  // 代码块</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>参考文档：<br><a href="https://blog.csdn.net/abuanden/article/details/115499301">https://blog.csdn.net/abuanden/article/details/115499301</a><br><a href="https://blog.csdn.net/Yu_Jian_Qt/article/details/107835536">https://blog.csdn.net/Yu_Jian_Qt/article/details/107835536</a></p>
]]></content>
      <tags>
        <tag>不以by小经验</tag>
        <tag>防抖节流</tag>
        <tag>debounce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC原理</title>
    <url>/2020/12/13/css/BFC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="一、BFC是什么？"><a href="#一、BFC是什么？" class="headerlink" title="一、BFC是什么？"></a>一、BFC是什么？</h2><p>   BFC(Block formatting context)直译为“块级格式化上下文”。它是一个独立渲染的区域，只有Block-level box参与，它规定了内部的Block-level box如何布局，并且与这个区域毫不相干。</p>
<h3 id="Box：CSS布局的基本单位"><a href="#Box：CSS布局的基本单位" class="headerlink" title="Box：CSS布局的基本单位"></a>Box：CSS布局的基本单位</h3><p>   Box是CSS布局的对象和基本单位，就是一个页面由很多个Box组成。元素的类型和display属性决定了这个Box类型。不同类型的Box会参与不同的Formatting Context（决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</p>
<ul>
<li>block-level box:display属性为block，list-item,table的元素，会生成Block-level box。并参与block formatting context</li>
<li>inline-level box:display属性为inline，inline-box,inline-table的元素，会生成inline-level box。并参与inlineformatting context</li>
</ul>
<h3 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h3><p>   Formatting Context是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其它元素的关系和相互作用。最常见的Formatting Context有Block formatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<h3 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h3><ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<h2 id="二、哪些元素会生成BFC"><a href="#二、哪些元素会生成BFC" class="headerlink" title="二、哪些元素会生成BFC?"></a>二、哪些元素会生成BFC?</h2><ol>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ol>
<h2 id="三、BFC的作用及原理"><a href="#三、BFC的作用及原理" class="headerlink" title="三、BFC的作用及原理"></a>三、BFC的作用及原理</h2><ol>
<li><p><strong>自适应两栏布局</strong></p>
<p>代码：</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#f66</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>   页面：</p>
<p>   <img src="https://img-blog.csdnimg.cn/img_convert/7faa738eb41327ae222e4ca9ade269cb.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>   根据<code>BFC</code>布局规则第3条：</p>
<blockquote>
<p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
</blockquote>
<p>   因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。</p>
<p>　 根据<code>BFC</code>布局规则第四条：</p>
<blockquote>
<p><code>BFC</code>的区域不会与<code>float box</code>重叠。</p>
</blockquote>
<p>　 可以通过通过触发main生成<code>BFC</code>， 来实现自适应两栏布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 当触发main生成<code>BFC</code>后，这个新的<code>BFC</code>不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：</p>
<p>　 <img src="https://img-blog.csdnimg.cn/img_convert/c46ea5c07957aca72d48c27b48bd4e3a.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 2. <strong>自适应两栏布局</strong></p>
<p>　 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.par</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;par&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 页面：</p>
<p>　 <img src="https://img-blog.csdnimg.cn/img_convert/f10763ac20a6f46917c2f7617aac692c.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 根据<code>BFC</code>布局规则第六条：</p>
<blockquote>
<p>计算<code>BFC</code>的高度时，浮动元素也参与计算</p>
</blockquote>
<p>　 为达到清除内部浮动，我们可以触发par生成<code>BFC</code>，那么par在计算高度时，par内部的浮动元素child也会参与计算。</p>
<p>　 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.par</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 效果如下：</p>
<p>　 <img src="https://img-blog.csdnimg.cn/img_convert/eddbef9df19df3df732d1ded9c9c902a.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 3. <strong>防止垂直 margin 重叠</strong></p>
<p>　 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 页面：</p>
<p>　 <img src="https://img-blog.csdnimg.cn/img_convert/13aea01d5ee36c3caeb789cd80cfadcd.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 两个p之间的距离为100px，发送了margin重叠。<br>　 根据BFC布局规则第二条：</p>
<blockquote>
<p><code>Box</code>垂直方向的距离由margin决定。属于同一个<code>BFC</code>的两个相邻<code>Box</code>的margin会发生重叠</p>
</blockquote>
<p>　 我们可以在p外面包裹一层容器，并触发该容器生成一个<code>BFC</code>。那么两个P便不属于同一个<code>BFC</code>，就不会发生margin重叠了。</p>
<p>　 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<p>　 效果如下:</p>
<p>　 <img src="https://img-blog.csdnimg.cn/img_convert/78cd862f248208dfd6446f9f780ff309.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>　 以上的几个例子都体现了<code>BFC</code>布局规则第五条：</p>
<blockquote>
<p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</blockquote>
<p>　 因为<code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部Box的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>css3 animation动画</title>
    <url>/2022/03/15/css/animation%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="css3判断animation动画是否完成，完成后暂停展示底部，然后重新开始"><a href="#css3判断animation动画是否完成，完成后暂停展示底部，然后重新开始" class="headerlink" title="css3判断animation动画是否完成，完成后暂停展示底部，然后重新开始"></a>css3判断animation动画是否完成，完成后暂停展示底部，然后重新开始</h1><h2 id="判断animation动画是否完成"><a href="#判断animation动画是否完成" class="headerlink" title="判断animation动画是否完成"></a>判断animation动画是否完成</h2><ol>
<li>用计时器，设定一个和动画时长一样的time，time事件结束去执行这个函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;, time)</span><br></pre></td></tr></table></figure></li>
<li>监听 <code>-webkit-animation</code> 动画结束事件<br>开始事件：<code>webkitAnimationStart</code><br>结束事件：<code>webkitAnimationEnd</code><br>重复运动事件：<code>webkitAnimationIteration</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Animation</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;webkitAnimationStart&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 动画开始时事件 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动画开始啦&#x27;</span>) <span class="comment">// 动画开始时，控制台输出1 </span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="title class_">Animation</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;webkitAnimationEnd&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 动画结束时的事件 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动画结束啦&#x27;</span>) <span class="comment">// 动画结束时，控制台输出2 </span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="title class_">Animation</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;webkitAnimationIteration&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 动画重复运动时的事件 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动画循环一次啦&#x27;</span>) <span class="comment">// 每一次循环动作完成时，控制台输出3 </span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>*注意：在监听事件中，this指向会被改变，可以在外面定义 <code>const _this = this</code></p>
<h2 id="动画完成后暂停展示底部内容"><a href="#动画完成后暂停展示底部内容" class="headerlink" title="动画完成后暂停展示底部内容"></a>动画完成后暂停展示底部内容</h2><p>在设置动画时通过设置 <code>animation-fill-mode</code> 属性来暂停</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: mymove <span class="number">10s</span> linear <span class="number">1</span> <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重新开始动画"><a href="#重新开始动画" class="headerlink" title="重新开始动画"></a>重新开始动画</h2><p>如果要重新开始动画，加载一个相同的动画，不同名字，就可以达到重新开始动画的效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> mymove &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;&#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> mymove1 &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;&#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: mymove <span class="number">10s</span> linear <span class="number">1</span> <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reset</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: mymove1 <span class="number">10s</span> linear <span class="number">1</span> <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>css选择器 和 css sprite</title>
    <url>/2021/01/26/css/css%E9%80%89%E6%8B%A9%E5%99%A8&amp;sprite/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="css选择器有哪些？"><a href="#css选择器有哪些？" class="headerlink" title="css选择器有哪些？"></a>css选择器有哪些？</h1><ol>
<li><em><strong>通用选择器</strong>：选择所有元素，</em>*不参与计算优先级**，兼容性 IE6+</li>
<li><strong>#X id 选择器</strong> ：选择 id 值为 X 的元素，兼容性 IE6+</li>
<li><strong>.X 类选择器</strong>： 选择 class 包含 X 的元素，兼容性 IE6+</li>
<li><strong>X Y 后代选择器</strong>：选择满足 X 选择器的后代节点中满足 Y 选择器的元素，兼容性 IE6+</li>
<li><strong>X 元素选择器</strong>：选择所有标签为 X 的元素，兼容性 IE6+</li>
<li><strong>:link，:visited，:focus，:hover，:active 链接状态</strong>： 选择特定状态的链接元素，顺序 LoVe HAte，兼容性: IE4+</li>
<li><strong>X + Y 直接兄弟选择器</strong>：在<strong>X 之后第一个兄弟节点</strong>中选择满足 Y 选择器的元素，兼容性： IE7+</li>
<li><strong>X &gt; Y 子选择器</strong>： 选择 X 的子元素中满足 Y 选择器的元素，兼容性： IE7+</li>
<li><strong>X ~ Y 兄弟</strong>： 选择<strong>X 之后所有兄弟节点</strong>中满足 Y 选择器的元素，兼容性： IE7+</li>
<li>**[attr]**：选择所有设置了 attr 属性的元素，兼容性 IE7+</li>
<li>**[attr=value]**：选择属性值刚好为 value 的元素</li>
<li>**[attr~=value]**：选择属性值为空白符分隔，其中一个的值刚好是 value 的元素</li>
<li>**[attr|=value]**：选择属性值刚好为 value 或者 value-开头的元素</li>
<li>**[attr^=value]**：选择属性值以 value 开头的元素</li>
<li>**[attr$=value]**：选择属性值以 value 结尾的元素</li>
<li>**[attr=value]***：选择属性值中包含 value 的元素</li>
<li>**[:checked]**：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+</li>
<li><strong>X:after, X::after</strong>：after 伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3 中::表示伪元素。兼容性:after 为 IE8+，::after 为 IE9+</li>
<li><strong>:hover</strong>：鼠标移入状态的元素，兼容性 a 标签 IE4+， 所有元素 IE7+</li>
<li><strong>:not(selector)<strong>：选择不符合 selector 的元素。</strong>不参与计算优先级</strong>，兼容性：IE9+</li>
<li><strong>::first-letter</strong>：伪元素，选择块元素第一行的第一个字母，兼容性 IE5.5+</li>
<li><strong>::first-line</strong>：伪元素，选择块元素的第一行，兼容性 IE5.5+</li>
<li>**:nth-child(an + b)**：伪类，选择前面有 an + b - 1 个兄弟节点的元素，其中 n &gt;= 0， 兼容性 IE9+</li>
<li>**:nth-last-child(an + b)**：伪类，选择后面有 an + b - 1 个兄弟节点的元素 其中 n &gt;= 0，兼容性 IE9+</li>
<li><strong>X:nth-of-type(an+b)<strong>：伪类，X 为选择器，</strong>解析得到元素标签</strong>，选择<strong>前面</strong>有 an + b - 1 个<strong>相同标签</strong>兄弟节点的元素。兼容性 IE9+</li>
<li><strong>X:nth-last-of-type(an+b)<strong>：伪类，X 为选择器，解析得到元素标签，选择</strong>后面</strong>有 an+b-1 个相同<strong>标签</strong>兄弟节点的元素。兼容性 IE9+</li>
<li><strong>X:first-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的第一个子元素。兼容性 IE7+</li>
<li><strong>X:last-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性 IE9+</li>
<li><strong>X:only-child</strong>：伪类，选择满足 X 选择器的元素，且这个元素是其父元素的唯一子元素。兼容性 IE9+</li>
<li><strong>X:only-of-type</strong>：伪类，选择 X 选择的元素，<strong>解析得到元素标签</strong>，如果该元素没有相同类型的兄弟节点时选中它。兼容性 IE9+</li>
<li><strong>X:first-of-type</strong>：伪类，选择 X 选择的元素，<strong>解析得到元素标签</strong>，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性 IE9+</li>
</ol>
<h1 id="css-sprite"><a href="#css-sprite" class="headerlink" title="css sprite"></a>css sprite</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>将多个小图片拼接到一个原片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ol>
<li>减少 HTTP 请求数，极大地提高页面加载速度</li>
<li>增加图片信息重复，提高压缩比，减少图片大小</li>
<li>更换风格方便，只需在一张或几张图上修改颜色或样式即可实现</li>
</ol>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ol>
<li>图片合并麻烦</li>
<li>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>多行文本垂直居中</title>
    <url>/2021/11/22/css/%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>我想要文本垂直居中于 div，但文本内容会被修改，文字宽度超出 div 宽度换行展示，但文本依然要垂直居中<br>说道垂直居中，第一反应就是 <code>line-height</code><br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/align.jpg?raw=true" alt="文字居中" loading="lazy"></p>
<p>但当文本出现换行就会变成这个样子<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/go-beyond.jpg?raw=true" alt="文字换行后的 line-height 效果" loading="lazy"></p>
<p>─ 你觉不觉得他很丑，而且怪怪的？</p>
<p>─ 嗯，我也这样觉得</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过 <code>display: table-cell;</code> 结合 <code>vertical-align: middle;</code> 来解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;banner&quot;&gt;</span><br><span class="line">    &lt;h1 class=&quot;sidebar-title&quot;&gt;test&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.banner &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  display: table;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sidebar-title &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  text-align: center;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>此时不管是多少行文字都是垂直居中于 div 的<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/banner.jpg?raw=true" alt="文字居中展示" loading="lazy"></p>
<p>相关文档：<a href="https://www.cnblogs.com/cowboybusy/p/11459408.html">https://www.cnblogs.com/cowboybusy/p/11459408.html</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>元素高度超出父级高度滚动展示</title>
    <url>/2021/11/22/css/%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="元素渲染展示"><a href="#元素渲染展示" class="headerlink" title="元素渲染展示"></a>元素渲染展示</h1><p>元素循环渲染到页面上，例如有如下数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题1&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题1的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题2&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题2的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题3&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题3的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题4&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题4的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题5&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题5的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题6&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题6的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题7&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题7的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题8&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题8的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题9&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题9的内容&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&#x27;我是标题10&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;我是标题10的内容&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>通过循环渲染到页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;marquee-view&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;marquee&quot;&gt;</span><br><span class="line">      &lt;li class=&quot;row&quot; v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;col&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/p&gt;&lt;p class=&quot;col&quot;&gt;&#123;&#123; item.content &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.marquee-view &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  margin-top: 5%;</span><br><span class="line">  width: 800px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.marquee &#123;</span><br><span class="line">  background: none;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.row &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  line-height: 1.05;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  color: #61a8ff;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.row:hover &#123;</span><br><span class="line">  background: rgba(255, 255, 255, 0.1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.row .col &#123;</span><br><span class="line">  width: 50%;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/scroll1.jpg?raw=true" alt="元素展示" loading="lazy"></p>
<p>现在就是这个样子的，很明显有一个元素被隐藏掉了，而我们需要让所有元素都展示出来，这个时候有两种解决方式：</p>
<ol>
<li>调整父盒子高度，让元素展示出来<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/height-change.png?raw=true" alt="调整父盒子高度" loading="lazy"></li>
<li>让子级盒子内的元素滚动展示</li>
</ol>
<h1 id="元素滚动"><a href="#元素滚动" class="headerlink" title="元素滚动"></a>元素滚动</h1><p>这里是通过 css3 动画来实现元素滚动的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> row &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;&#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用动画 */</span></span><br><span class="line"><span class="selector-class">.marquee</span> &#123;</span><br><span class="line">  <span class="comment">/* //infinite永久调用动画 */</span></span><br><span class="line">  <span class="attribute">animation</span>: row <span class="number">15s</span> linear <span class="number">1s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标划入 停止动画  */</span></span><br><span class="line"><span class="selector-class">.marquee</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里顺便提一下 <code>animation</code> 的属性</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>animation-name</code></td>
<td align="center">规定需要绑定到选择器的 keyframe 名称。</td>
</tr>
<tr>
<td align="center"><code>animation-duration</code></td>
<td align="center">规定完成动画所花费的时间，以秒或毫秒计。</td>
</tr>
<tr>
<td align="center"><code>animation-timing-function</code></td>
<td align="center">规定动画的速度曲线。</td>
</tr>
<tr>
<td align="center"><code>animation-delay</code></td>
<td align="center">规定在动画开始之前的延迟。</td>
</tr>
<tr>
<td align="center"><code>animation-iteration-count</code></td>
<td align="center">规定动画应该播放的次数。</td>
</tr>
<tr>
<td align="center"><code>animation-direction</code></td>
<td align="center">规定是否应该轮流反向播放动画。</td>
</tr>
</tbody></table>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration timing-function delay iteration-count direction;</span><br></pre></td></tr></table></figure>

<p>来看一下效果吧：<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/scroll.gif?raw=true" alt="滚动" loading="lazy"></p>
<h1 id="根据父级盒子高度滚动"><a href="#根据父级盒子高度滚动" class="headerlink" title="根据父级盒子高度滚动"></a>根据父级盒子高度滚动</h1><p>通过上图又可以发现两个问题：</p>
<ol>
<li>css3 动画会一直滚动，如果子级元素高度没有超过父级盒子高度想要不滚动怎么办</li>
<li>这样滚动数据会空出一段，不好看，想要超出父级高度后让数据实现无缝循环展示</li>
</ol>
<p>所以我们需要判断子级高度是否超出了父级盒子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;marquee&quot; class=&quot;marquee-view&quot;&gt;</span><br><span class="line">    &lt;table ref=&quot;stop&quot; class=&quot;marquee&quot;&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot; class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;th class=&quot;col&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/th&gt;</span><br><span class="line">        &lt;th class=&quot;col&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getHeight() &#123;</span><br><span class="line">      this.Height = this.$refs.marquee.offsetHeight // 获取父级高度</span><br><span class="line">      if (this.list.length * 30 &gt; this.Height) &#123; // this.list存放数据，当数据条数 * 展示的高度 超出父级高度</span><br><span class="line">        this.list = this.list.concat(this.list)  // 叠加数据</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.$refs.stop.className = &#x27;marquee stop&#x27; // 暂停滚动</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.marquee.stop &#123;</span><br><span class="line">  animation-play-state: paused;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>来看一下效果<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/css/seamless_scrolling.gif?raw=true" alt="无缝滚动" loading="lazy"></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git指令</title>
    <url>/2020/07/08/git/git%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="在项目仓库创建自己的分支，并将本地项目推送到远程仓库"><a href="#在项目仓库创建自己的分支，并将本地项目推送到远程仓库" class="headerlink" title="在项目仓库创建自己的分支，并将本地项目推送到远程仓库"></a>在项目仓库创建自己的分支，并将本地项目推送到远程仓库</h2><p><strong>1.拉取远程仓库到本地文件夹中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/......</span><br></pre></td></tr></table></figure>

<p><strong>2.进入拉取的文件夹</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ...</span><br></pre></td></tr></table></figure>

<p><strong>3.创建自己的分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>4.推送分支到gitee上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="添加（删除）文件，推送到远程"><a href="#添加（删除）文件，推送到远程" class="headerlink" title="添加（删除）文件，推送到远程"></a>添加（删除）文件，推送到远程</h2><p><strong>1.拉取文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p><strong>2.将文件推送到缓存区</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add 文件名 // 二选一</span><br></pre></td></tr></table></figure>

<p><strong>3.将文件推送到本地库中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;新添加的文件描述&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>4.推送到远程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push -f origin master // 强制推送，特殊情况无法提交时使用</span><br></pre></td></tr></table></figure>

<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><p>在删除分支的时候,我们会使用 <code>git branch --delete dev</code> 来执行.有时还会通过缩写 <code>git branch -d dev</code> 来代替.使用中我们发现还有 <code>git branch -D dev</code> 的写法,他们有什么区别呢?</p>
<p>-d是–delete的缩写,在使用–delete删除分支时,该分支必须完全和它的上游分支merge完成,如果没有上游分支,必须要和HEAD完全merge<br>-D是–delete –force的缩写,这样写可以在不检查merge状态的情况下删除分支</p>
<p>–force简写-f,作用是将当前branch重置到初始点,如果不使用–force的话,git分支无法修改一个已经存在的分支.</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>指令 <code>git push origin --delete branch</code> ,该指令也会删除追踪分支</p>
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.2.2/images/git/deleteRemotely.webp" alt="删除追踪分支和远程分支" loading="lazy"></p>
<h3 id="删除追踪分支"><a href="#删除追踪分支" class="headerlink" title="删除追踪分支"></a>删除追踪分支</h3><p>通过指令 <code>git branch --delete --remotes &lt;remote&gt;/&lt;branch&gt;</code> ,可以删除追踪分支,该操作并没有真正删除远程分支,而是删除的本地分支和远程分支的关联关系,即追踪分支.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.2.2/images/git/deleteTrack.webp" alt="删除追踪分支" loading="lazy"></p>
<p>通过命令行 <code>git push origin --delete branch</code> 会删除远程分支和追踪分支,不需要单独删除追踪分支,但是如果通过网页对远程分支进行删除,追踪分支是不会被删除的.</p>
<p>在git版本1.6.6之后,可以通过 <code>git fetch origin --prune</code> 或它的简写 <code>git fetch origin -p</code> 来单独删除追踪分支</p>
<p>删除分支相关文档：<a href="https://www.jianshu.com/p/5068997164cb">https://www.jianshu.com/p/5068997164cb</a></p>
<h2 id="修改分支名"><a href="#修改分支名" class="headerlink" title="修改分支名"></a>修改分支名</h2><p>旧分支名用 oldName 代替，新分支名用 newName 代替</p>
<h3 id="本地分支重命名-还没有推送到远程"><a href="#本地分支重命名-还没有推送到远程" class="headerlink" title="本地分支重命名(还没有推送到远程)"></a>本地分支重命名(还没有推送到远程)</h3><p><code>git branch -m oldName newName</code></p>
<h3 id="远程分支重命名-已经推送远程-假设本地分支和远程对应分支名称相同"><a href="#远程分支重命名-已经推送远程-假设本地分支和远程对应分支名称相同" class="headerlink" title="远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)"></a>远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</h3><h4 id="重命名远程分支对应的本地分支"><a href="#重命名远程分支对应的本地分支" class="headerlink" title="重命名远程分支对应的本地分支"></a>重命名远程分支对应的本地分支</h4><p><code>git branch -m oldName newName</code></p>
<h4 id="删除远程分支-1"><a href="#删除远程分支-1" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p><code>git push --delete origin oldName</code></p>
<h4 id="上传新命名的本地分支"><a href="#上传新命名的本地分支" class="headerlink" title="上传新命名的本地分支"></a>上传新命名的本地分支</h4><p><code>git push origin newName</code></p>
<h4 id="把修改后的本地分支与远程分支关联"><a href="#把修改后的本地分支与远程分支关联" class="headerlink" title="把修改后的本地分支与远程分支关联"></a>把修改后的本地分支与远程分支关联</h4><p><code>git branch --set-upstream-to origin/newName</code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>字节一面</title>
    <url>/2021/04/02/interview/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="1-http请求头中有哪些内容"><a href="#1-http请求头中有哪些内容" class="headerlink" title="1. http请求头中有哪些内容"></a>1. http请求头中有哪些内容</h2><h2 id="2-块级作用域和变量提升"><a href="#2-块级作用域和变量提升" class="headerlink" title="2.块级作用域和变量提升"></a>2.块级作用域和变量提升</h2><h2 id="3-函数有变量提升吗？"><a href="#3-函数有变量提升吗？" class="headerlink" title="3.函数有变量提升吗？"></a>3.函数有变量提升吗？</h2><h2 id="4-普通函数和箭头函数区别"><a href="#4-普通函数和箭头函数区别" class="headerlink" title="4.普通函数和箭头函数区别"></a>4.普通函数和箭头函数区别</h2><h2 id="5-如何判断一个对象是NaN"><a href="#5-如何判断一个对象是NaN" class="headerlink" title="5.如何判断一个对象是NaN"></a>5.如何判断一个对象是NaN</h2><h2 id="6-Vue实现双向数据绑定的原理，能手写吗（不会写qwq）"><a href="#6-Vue实现双向数据绑定的原理，能手写吗（不会写qwq）" class="headerlink" title="6.Vue实现双向数据绑定的原理，能手写吗（不会写qwq）"></a>6.Vue实现双向数据绑定的原理，能手写吗（不会写qwq）</h2><h2 id="7-v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）"><a href="#7-v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）" class="headerlink" title="7.v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）"></a>7.v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）</h2><h2 id="8-v-if和v-show的区别"><a href="#8-v-if和v-show的区别" class="headerlink" title="8.v-if和v-show的区别"></a>8.v-if和v-show的区别</h2><h2 id="9-js原型和原型链"><a href="#9-js原型和原型链" class="headerlink" title="9.js原型和原型链"></a>9.js原型和原型链</h2><h2 id="10-js的数组有哪些方法？Array-prototype-sort-底层实现？"><a href="#10-js的数组有哪些方法？Array-prototype-sort-底层实现？" class="headerlink" title="10.js的数组有哪些方法？Array.prototype.sort()底层实现？"></a>10.js的数组有哪些方法？Array.prototype.sort()底层实现？</h2><h2 id="11-手写一下快速排序"><a href="#11-手写一下快速排序" class="headerlink" title="11.手写一下快速排序"></a>11.手写一下快速排序</h2><h2 id="12-自我介绍"><a href="#12-自我介绍" class="headerlink" title="12.自我介绍"></a>12.自我介绍</h2><h2 id="13-http请求头中有哪些内容"><a href="#13-http请求头中有哪些内容" class="headerlink" title="13.http请求头中有哪些内容"></a>13.http请求头中有哪些内容</h2><h2 id="14-块级作用域和变量提升"><a href="#14-块级作用域和变量提升" class="headerlink" title="14.块级作用域和变量提升"></a>14.块级作用域和变量提升</h2><h2 id="15-函数有变量提升吗？"><a href="#15-函数有变量提升吗？" class="headerlink" title="15.函数有变量提升吗？"></a>15.函数有变量提升吗？</h2><h2 id="16-普通函数和箭头函数区别"><a href="#16-普通函数和箭头函数区别" class="headerlink" title="16.普通函数和箭头函数区别"></a>16.普通函数和箭头函数区别</h2><h2 id="17-如何判断一个对象是NaN"><a href="#17-如何判断一个对象是NaN" class="headerlink" title="17.如何判断一个对象是NaN"></a>17.如何判断一个对象是NaN</h2><h2 id="18-Vue实现双向数据绑定的原理，能手写吗（不会写qwq）"><a href="#18-Vue实现双向数据绑定的原理，能手写吗（不会写qwq）" class="headerlink" title="18.Vue实现双向数据绑定的原理，能手写吗（不会写qwq）"></a>18.Vue实现双向数据绑定的原理，能手写吗（不会写qwq）</h2><h2 id="19-v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）"><a href="#19-v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）" class="headerlink" title="19.v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）"></a>19.v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）</h2><h2 id="20-v-if和v-show的区别"><a href="#20-v-if和v-show的区别" class="headerlink" title="20.v-if和v-show的区别"></a>20.v-if和v-show的区别</h2><h2 id="21-js原型和原型链"><a href="#21-js原型和原型链" class="headerlink" title="21.js原型和原型链"></a>21.js原型和原型链</h2><h2 id="22-js的数组有哪些方法？Array-prototype-sort-底层实现？"><a href="#22-js的数组有哪些方法？Array-prototype-sort-底层实现？" class="headerlink" title="22.js的数组有哪些方法？Array.prototype.sort()底层实现？"></a>22.js的数组有哪些方法？Array.prototype.sort()底层实现？</h2><h2 id="23-手写一下快速排序"><a href="#23-手写一下快速排序" class="headerlink" title="23.手写一下快速排序"></a>23.手写一下快速排序</h2>]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM与MVC的区别</title>
    <url>/2020/12/25/vue/MVVM%E4%B8%8EMVC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>MV* 是指各种 MVC、MVVM 等 Web 设计模式，通过分离关注点来改进代码的组织方式，设计模式并不是凭空的创造，而是对复杂问题解决的不断提炼，即使没有看过这些设计模式的介绍，也许在日常开发中就已经使用了其中的思想</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM 是<strong>Model-View-ViewModel</strong>的简写。即<strong>模型-视图-视图模型</strong>。Model 指的是后端传递的数据。</p>
<p>View 指的是所看到的页面。ViewModel 是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。</p>
<p>它有两个方向：</p>
<ul>
<li>一是将 model 转化成 view，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</li>
<li>二是将 view 转化成 model，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li>
<li>这两个方向都实现的，称之为数据的双向绑定。</li>
</ul>
<p>在 MVVM 的框架下视图和模型是不能直接通信的。它们通过 ViewModel 来通信，ViewModel 通常要实现一个 observer 观察者，当数据发生变化，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且 MVVM 中的 View 和 ViewModel 可以互相通信。</p>
<p>MVVM 流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/vue/MVVM.png?raw=true" alt="MVVM流程图" loading="lazy"></p>
<h4 id="MVVM-优点："><a href="#MVVM-优点：" class="headerlink" title="MVVM 优点："></a>MVVM 优点：</h4><p>MVVM 模式和 MVC 模式类似，<strong>主要目的是分离视图（View）和模型（Model）</strong>，有几大优点：</p>
<ul>
<li><strong>低耦合</strong>，视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
<li><strong>可重用性</strong>，可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li>
<li><strong>独立开发</strong>，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li>
<li><strong>可测试</strong>，界面向来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 是 Model View Controller 的缩写</p>
<ul>
<li>Model：模型层，数据相关的操作</li>
<li>View：视图层，用户界面渲染逻辑</li>
<li>Controller：控制器，数据模型和视图之间通信的桥梁</li>
</ul>
<p>MVC 模型有很多变种和数据流动方式，最传统的 MVC 模型把视图渲染和数据处理做了隔离，通过控制器接收 View 操作，传递给数据模型，数据 ready 后由数据模型驱动视图渲染</p>
<h4 id="MVC-特点："><a href="#MVC-特点：" class="headerlink" title="MVC 特点："></a>MVC 特点：</h4><p>MVC 模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端 web 开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的 HTML 元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p>
<ul>
<li>View 传送指令到 Controller ；</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态 ；</li>
<li>Model 将新的数据发送到 View，用户得到反馈。</li>
</ul>
<h4 id="MVC-流程："><a href="#MVC-流程：" class="headerlink" title="MVC 流程："></a>MVC 流程：</h4><p><img src="http://nixwang.com/2016-03-23/mvvm.png" loading="lazy"></p>
<h4 id="MVC-优点："><a href="#MVC-优点：" class="headerlink" title="MVC 优点："></a>MVC 优点：</h4><ul>
<li><strong>耦合性低</strong>，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。</li>
<li><strong>重用性高</strong></li>
<li><strong>生命周期成本低</strong></li>
<li><strong>MVC 使开发和维护用户接口的技术含量降低</strong></li>
<li><strong>可维护性高</strong>，分离视图层和业务逻辑层也使得 WEB 应用更易于维护和修改</li>
<li><strong>部署快</strong></li>
</ul>
<h4 id="MVC-缺点"><a href="#MVC-缺点" class="headerlink" title="MVC 缺点"></a>MVC 缺点</h4><ul>
<li><strong>不适合小型，中等规模的应用程序</strong>，花费大量时间将 MVC 应用到规模并不是很大的应用程序通常会得不偿失。</li>
<li><strong>视图与控制器间过于紧密连接</strong>，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li><strong>视图对模型数据的低效率访问</strong>，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue父组件异步传值，子组件获取props并渲染</title>
    <url>/2022/04/08/vue/props%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>昨天在写需求时遇到一个问题，父组件异步获取数据传递给子组件，子组件通过props获取监听不到内容<br>如图：需要给这个组件传值并渲染<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/vue/MVVM.png?raw=true" alt="需求" loading="lazy"><br>因为并不是一个接口获取值得，所以定义了一个对象 <code>PanelTotal</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title class_">PanelTotal</span>: &#123;</span><br><span class="line">      <span class="attr">first</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">second</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">third</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">fourth</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在子组件却监听不到数据，为此我尝试了多种方法：</p>
<ol>
<li>将 <code>PanelTotal</code> 中的值改为数组格式</li>
<li>将 <code>PanelTotal</code> 中的单独列出</li>
<li>……</li>
</ol>
<p>无一例外都失败了</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>按照以上方法尝试过后心情很烦躁，于是出去走走放松了一下，此时我想到一个新思路，单独查找了<strong>Vue 中 props监听变化的几种方式</strong>，终于找到了解决方法：<br>深度监听的引用类型中，通过计算属性得到引用类型的内部某个字段，再使用侦听器监听该字段的变化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">chartData</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="title function_">default</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">chartData</span>.<span class="property">first</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">chartData</span>.<span class="property">second</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">third</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">chartData</span>.<span class="property">third</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">fourth</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">chartData</span>.<span class="property">fourth</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就解决了！<br>注意：因为在dom元素中设置了 <code>v-if</code> 判断，所以 <code>PanelTotal</code> 中的值要设置为 <code>&#123;&#125;</code> 格式，否则可能会导致元素移位哦</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-keep-alive组件</title>
    <url>/2021/01/29/vue/vue-keep-alive%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>keep-alive</code>是<code>Vue</code>提供的一个抽象组件，主要用于保留组件状态或避免重新渲染。</p>
<p><keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>
<h1 id="关于keep-alive"><a href="#关于keep-alive" class="headerlink" title="关于keep-alive"></a><strong>关于keep-alive</strong></h1><p><strong>1. 基本使用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以根据条件判断： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-a</span> <span class="attr">v-if</span>=<span class="string">&quot;a &gt; 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-b</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个时候触发两个组件切换时，组件内的数据和状态都会得到保存，如果有input输入框，输入框内容会保留 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 有条件缓存</strong></p>
<p>keep-alive提供了include、exclude、max三个参数，前两个允许组件有条件的进行缓存，两者都可以接受字符串、正则、数组形式；max表示最多可以缓存多少个组件，接受一个number类型。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此时只有a、b两个组件会触发keep-alive，此处的名字是组件内部name对应名字，如果name不存在，会查找父组件里components里注册的名字，如果也不存在则不会匹配。</span></span><br><span class="line"><span class="comment">正则和数组方法同上，但是需要用v-bind:include=&#x27;&#x27;方式。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:max</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>生命钩子 keep-alive提供了两个生命钩子，分别是 <code>activated</code> 与 <code>deactivated</code> 。</p>
<p>因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用 <code>activated</code> 与 <code>deactivated</code> 这两个生命钩子来得知当前组件是否处于活动状态。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title>vue---vuex与全局对象的区别及使用</title>
    <url>/2021/01/29/vue/vue-vuex%E4%B8%8E%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="1-vuex与全局对象的区别"><a href="#1-vuex与全局对象的区别" class="headerlink" title="1. vuex与全局对象的区别"></a>1. vuex与全局对象的区别</h1><blockquote>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是****响应式****的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。****改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation*<em><strong>。这样使得我们可以</strong>方便地跟踪每一个状态的变化</em>*，从而让我们能够实现一些工具帮助我们更好地了解我们的应用</li>
</ol>
</blockquote>
<ol>
<li><p>vuex用于做状态管理，主要是应用于vue.js中管理数据状态的一个库，通过创建一个集中的数据存储，供程序中所有组件访问，实现组件之间的传值。并且一个组件的数据变化会映射到使用这个数据的其他组件。</p>
</li>
<li><p>vuex由统一的方法修改数据，全局变量可以任意修改。</p>
</li>
<li><p>全局变量多了会造成命名污染，vuex不会，同时解决了父组件与孙组件，以及兄弟组件之间通信的问题。</p>
</li>
</ol>
<h1 id="2-vue定义全局变量"><a href="#2-vue定义全局变量" class="headerlink" title="2. vue定义全局变量"></a>2. vue定义全局变量</h1><p>方法一：新建全局【global.js】文件，并在其中定义变量并导出，在使用的组件中引入该【global.js】文件，可为全局变量赋值（任意修改）或使用其值。</p>
<p>方法二：在【main.js】中引入【global.js】：<code>import global from &quot;../api/global.js&quot;;</code>，并通过<code>Vue.prototype.global=global</code>挂载到vue实例上，在其他组件中通过<code>this.global.authorization</code>调用。</p>
<h1 id="3-vue定义全局方法"><a href="#3-vue定义全局方法" class="headerlink" title="3. vue定义全局方法"></a>3. vue定义全局方法</h1><p>直接将方法写在【main.js】中，在组件中通过this.方法名 调用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>vue异步组件</title>
    <url>/2021/01/29/vue/vue%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="异步组件三种方式"><a href="#异步组件三种方式" class="headerlink" title="异步组件三种方式"></a>异步组件三种方式</h1><ol>
<li>普通函数异步组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&lt;p&gt;&#123;&#123;aa&#125;&#125;&lt;span&gt;&#123;&#123;bb&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">aa</span>: <span class="string">&#x27;欢迎&#x27;</span>,</span><br><span class="line">                    <span class="attr">bb</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise 异步组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./aa.js&#x27;</span>) )</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>高级异步组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">aa</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">    <span class="comment">// 需要加载的组件。应当是一个 Promise</span></span><br><span class="line">    <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./aa.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">    <span class="attr">loading</span>: <span class="title class_">LoadingComp</span>,</span><br><span class="line">    <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">    <span class="attr">error</span>: <span class="title class_">ErrorComp</span>,</span><br><span class="line">    <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms。</span></span><br><span class="line">    <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, aa)</span><br></pre></td></tr></table></figure>

<p>从以上示例中可以看到，通过<code>Vue.component</code>注册的组件不再是一个对象，而是一个函数，这个函数也不是组件构造函数，是一个工厂函数。这个工厂函数有两个参数<code>resolve</code>函数和<code>reject</code>函数，其是 Vue 内部定义的，在这个工厂函数中有个异步函数，当异步函数执行成功后调用<code>resolve</code>函数，其参数就是异步组件的对象。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>组件的使用，要先在<code>vm._render</code>过程中执行<code>vnode = createComponent(Ctor, data, context, children, tag)</code>生成<code>vnode</code>，其中参数<code>Ctor</code>可以是函数或对象，从<code>createComponent</code>方法开始介绍异步组件是如何使用。</p>
<h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a><code>createComponent</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span>(<span class="params">Ctor, data, context, children, tag</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">        <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Ctor</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// async component</span></span><br><span class="line">    <span class="keyword">var</span> asyncFactory</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) &#123;</span><br><span class="line">        asyncFactory = <span class="title class_">Ctor</span></span><br><span class="line">        <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(asyncFactory, data, context, children, tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    <span class="title function_">resolveConstructorOptions</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">    <span class="title function_">installComponentHooks</span>(data)</span><br><span class="line">    <span class="keyword">var</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag</span><br><span class="line">    <span class="keyword">var</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        (<span class="string">&#x27;vue-component-&#x27;</span> + (<span class="title class_">Ctor</span>.<span class="property">cid</span>) + (name ? (<span class="string">&#x27;-&#x27;</span> + name) : <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">        data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context, &#123;</span><br><span class="line">            <span class="title class_">Ctor</span>: <span class="title class_">Ctor</span>,</span><br><span class="line">            <span class="attr">tag</span>: tag,</span><br><span class="line">            <span class="attr">children</span>: children</span><br><span class="line">        &#125;,</span><br><span class="line">        asyncFactory</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数<code>Ctor</code>值的类型是函数时，不会执行<code>Ctor = baseCtor.extend(Ctor)</code>。</p>
<p>因为在 Vue 中是调用<code>Vue.extend</code>方法来创建继承 Vue 的组件构造函数。在<code>Vue.extend</code>中会执行<code>Sub.cid = cid++</code>给组件构造函数的<code>cid</code>属性赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cid = <span class="number">1</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">extend</span> = <span class="keyword">function</span>(<span class="params">extendOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span></span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">cid</span> = cid++</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Sub</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以用<code>isUndef(Ctor.cid)</code>来判断<code>Ctor</code>是不是一个组件构造函数，若不是执行<code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor)</code>进入异步组件使用的逻辑。</p>
<h2 id="resolveAsyncComponent"><a href="#resolveAsyncComponent" class="headerlink" title="resolveAsyncComponent"></a><code>resolveAsyncComponent</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsyncComponent</span>(<span class="params">factory, baseCtor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">error</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">errorComp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> owner = currentRenderingInstance</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">owners</span>) &amp;&amp; factory.<span class="property">owners</span>.<span class="title function_">indexOf</span>(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">        factory.<span class="property">owners</span>.<span class="title function_">push</span>(owner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">loading</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">loadingComp</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loadingComp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !<span class="title function_">isDef</span>(factory.<span class="property">owners</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> owners = factory.<span class="property">owners</span> = [owner]</span><br><span class="line">        <span class="keyword">var</span> sync = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> timerLoading = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> timerTimeout = <span class="literal">null</span></span><br><span class="line">        (owner).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">remove</span>(owners, owner)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> forceRender = <span class="keyword">function</span>(<span class="params">renderCompleted</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; l = owners.<span class="property">length</span>; i &lt; l i++) &#123;</span><br><span class="line">                (owners[i]).$forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">                    timerLoading = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">                    timerTimeout = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">            <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> reject = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&#x27;Failed to resolve async component: &#x27;</span> + (<span class="title class_">String</span>(factory)) +</span><br><span class="line">                (reason ? (<span class="string">&#x27;\nReason: &#x27;</span> + reason) : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">                factory.<span class="property">error</span> = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> res = <span class="title function_">factory</span>(resolve, reject)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isPromise</span>(res)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">                    res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPromise</span>(res.<span class="property">component</span>)) &#123;</span><br><span class="line">                res.<span class="property">component</span>.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">error</span>)) &#123;</span><br><span class="line">                    factory.<span class="property">errorComp</span> = <span class="title function_">ensureCtor</span>(res.<span class="property">error</span>, baseCtor)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">loading</span>)) &#123;</span><br><span class="line">                    factory.<span class="property">loadingComp</span> = <span class="title function_">ensureCtor</span>(res.<span class="property">loading</span>, baseCtor)</span><br><span class="line">                    <span class="keyword">if</span> (res.<span class="property">delay</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                        factory.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        timerLoading = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                            timerLoading = <span class="literal">null</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>) &amp;&amp; <span class="title function_">isUndef</span>(factory.<span class="property">error</span>)) &#123;</span><br><span class="line">                                factory.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">                                <span class="title function_">forceRender</span>(<span class="literal">false</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, res.<span class="property">delay</span> || <span class="number">200</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">timeout</span>)) &#123;</span><br><span class="line">                    timerTimeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        timerTimeout = <span class="literal">null</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">                            <span class="title function_">reject</span>(</span><br><span class="line">                                <span class="string">&#x27;timeout (&#x27;</span> + (res.<span class="property">timeout</span>) + <span class="string">&#x27;ms)&#x27;</span></span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, res.<span class="property">timeout</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sync = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loading</span> ? factory.<span class="property">loadingComp</span> : factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>resolveAsyncComponent</code>函数，是个高阶函数，主要对注册异步组件时，传入不同的工厂函数进行处理，内部定义了工厂函数的参数<code>resolve</code>函数和<code>reject</code>函数，并调用了工厂函数，成功执行<code>resolve</code>函数，失败执行<code>reject</code>函数，最后返回组件构造函数或 undefined。</p>
<p>异步组件和同步组件的注册原理是一样，只是异步组件的使用原理跟同步组件是不一样的。</p>
<h1 id="异步组件的使用原理"><a href="#异步组件的使用原理" class="headerlink" title="异步组件的使用原理"></a>异步组件的使用原理</h1><h2 id="1-普通函数异步组件"><a href="#1-普通函数异步组件" class="headerlink" title="1. 普通函数异步组件"></a>1. 普通函数异步组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&lt;p&gt;&#123;&#123;aa&#125;&#125;&lt;span&gt;&#123;&#123;bb&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">aa</span>: <span class="string">&#x27;欢迎&#x27;</span>,</span><br><span class="line">                    <span class="attr">bb</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>resolveAsyncComponent(factory, baseCtor)</code>，参数<code>factory</code>的值就是上面<code>Vue.component</code>的第二参数，参数<code>baseCtor</code>是 Vue 构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsyncComponent</span>(<span class="params">factory, baseCtor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> owner = currentRenderingInstance</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">owners</span>) &amp;&amp; factory.<span class="property">owners</span>.<span class="title function_">indexOf</span>(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">        factory.<span class="property">owners</span>.<span class="title function_">push</span>(owner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !<span class="title function_">isDef</span>(factory.<span class="property">owners</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> owners = factory.<span class="property">owners</span> = [owner]</span><br><span class="line">        <span class="keyword">var</span> sync = <span class="literal">true</span></span><br><span class="line">        (owner).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">remove</span>(owners, owner)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> forceRender = <span class="keyword">function</span>(<span class="params">renderCompleted</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; l = owners.<span class="property">length</span>; i &lt; l i++) &#123;</span><br><span class="line">                (owners[i]).$forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">            <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> reject = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&quot;Failed to resolve async component: &quot;</span> + (<span class="title class_">String</span>(factory)) +</span><br><span class="line">                (reason ? (<span class="string">&quot;\nReason: &quot;</span> + reason) : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> res = <span class="title function_">factory</span>(resolve, reject)</span><br><span class="line">        sync = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loading</span> ? factory.<span class="property">loadingComp</span> : factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>resolveAsyncComponent</code> 函数中，内部定义了三个函数 <code>forceRender</code>、<code>resolve</code>、<code>reject</code>。其中 <code>resolve</code> 和 <code>reject</code> 函数是用 <code>once</code> 函数包装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">once</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>once</code> 函数是个高阶函数，巧妙利用闭包和 <code>called</code> 变量，保证所包装的函数只执行一次。也就是确保 <code>resolve</code> 和 <code>reject</code> 函数只执行一次。</p>
<p>因为在 <code>resolveAsyncComponent</code> 函数中最后执行 <code>return factory.loading ? factory.loadingComp : factory.resolved</code>，返回 <code>factory.resolved</code>。</p>
<p><code>factory.resolved</code> 定义在<code>resolve</code>函数中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行 <code>ensureCtor(res, baseCtor)</code> 后赋值给 <code>factory.resolved</code> ，来看一下 <code>ensureCtor </code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureCtor</span>(<span class="params">comp, base</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        comp.<span class="property">__esModule</span> ||</span><br><span class="line">        (hasSymbol &amp;&amp; comp[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] === <span class="string">&#x27;Module&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        comp = comp.<span class="property">default</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(comp) ?</span><br><span class="line">        base.<span class="title function_">extend</span>(comp) :</span><br><span class="line">        comp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>base</code>为 Vue 构造函数，那么最后执行<code>return isObject(comp) ? base.extend(comp) : comp</code>，如果参数<code>comp</code>是个对象，执行<code>base.extend(comp)</code>，也就是执行<code>Vue.extend(comp)</code>生成一个继承 Vue 的构造函数。</p>
<p>参数<code>comp</code>是通过<code>resolve</code>函数的参数<code>res</code>传参的。回到<code>resolveAsyncComponent</code>方法中，有执行<code>var res = factory(resolve, reject)</code>这段代码，<code>factory</code>是通过<code>Vue.component</code>的第二参数传参的，值如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&lt;p&gt;&#123;&#123;aa&#125;&#125;&lt;span&gt;&#123;&#123;bb&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">aa</span>: <span class="string">&#x27;欢迎&#x27;</span>,</span><br><span class="line">                    <span class="attr">bb</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>resolve</code>就是<code>resolveAsyncComponent</code>函数内部定义的<code>resolve</code>函数。那么参数<code>comp</code>的值如下所示，是个组件的选项对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&lt;p&gt;&#123;&#123;aa&#125;&#125;&lt;span&gt;&#123;&#123;bb&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">aa</span>: <span class="string">&#x27;欢迎&#x27;</span>,</span><br><span class="line">            <span class="attr">bb</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样执行<code>ensureCtor(res, baseCtor)</code>会得到一个组件构造函数，那么<code>factory.resolved</code>的值为一个组件构造函数。</p>
<p>再回到<code>createComponent</code>方法中，看这段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor)</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(asyncFactory, data, context, children, tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>resolveAsyncComponent</code>方法后返回一个组件构造函数赋值给<code>Ctor</code>。就这么结束了吗。当然不是了，不知你有没有注意到在<code>Vue.component</code>定义的第二参数中，<code>resolve(//...)</code>外层还有一个<code>setTimeout</code>定时器，是个异步任务。JavaScript 是单线程的，异步任务要等所有同步任务都执行完才能执行。故此时<code>resolveAsyncComponent</code>方法中的<code>resolve</code>函数是不执行，<code>factory.resolved</code>应该为 undefined 。那么<code>Ctor</code>为 undefined ，要执行<code>return createAsyncPlaceholder(asyncFactory, data, context, children, tag)</code>。<code>createAsyncPlaceholder</code>方法是用来创建一个注释节点<code>vnode</code>作为占位符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAsyncPlaceholder</span>(<span class="params">factory, data, context, children, tag</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    node.<span class="property">asyncFactory</span> = factory</span><br><span class="line">    node.<span class="property">asyncMeta</span> = &#123;</span><br><span class="line">        <span class="attr">data</span>: data,</span><br><span class="line">        <span class="attr">context</span>: context,</span><br><span class="line">        <span class="attr">children</span>: children,</span><br><span class="line">        <span class="attr">tag</span>: tag</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>createComponent</code>方法生成的一个注释节点<code>vnode</code>，而不是一个组件<code>vnode</code>，那组件要怎么渲染，不着急，再回到<code>resolveAsyncComponent</code>方法中，在 return 之前执行<code>sync = false</code>，在1000ms后<code>resolve</code>函数执行，会执行<code>forceRender(true)</code>，来看一下<code>forceRender</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> owner = currentRenderingInstance</span><br><span class="line"><span class="keyword">if</span> (owner &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">owners</span>) &amp;&amp; factory.<span class="property">owners</span>.<span class="title function_">indexOf</span>(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">    factory.<span class="property">owners</span>.<span class="title function_">push</span>(owner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (owner &amp;&amp; !<span class="title function_">isDef</span>(factory.<span class="property">owners</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> owners = factory.<span class="property">owners</span> = [owner]</span><br><span class="line">    <span class="keyword">var</span> forceRender = <span class="keyword">function</span>(<span class="params">renderCompleted</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; l = owners.<span class="property">length</span>; i &lt; l i++) &#123;</span><br><span class="line">            (owners[i]).$forceUpdate()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">            owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>currentRenderingInstance</code>是使用异步组件的当前 Vue 实例，赋值给<code>owner</code>。</p>
<p>如果同一个异步组件在很多个地方局部注册。这样要重复执行很多次相同的<code>resolve</code>函数。所以在这里做了个优化。</p>
<p>异步组件是以一个工厂函数<code>factory</code>来定义组件，在<code>factory</code>定义一个属性<code>owners</code>，来存储使用异步组件的当前 Vue 实例，也就是调用<code>factory</code>函数的上下文环境。</p>
<p>若<code>owner</code>有值和<code>factory.owners</code>不存在，则说明<code>factory</code>函数是第一次执行。若<code>owner</code>有值和<code>factory.owners</code>有值，则说明<code>factory</code>函数已经执行过了。执行<code>factory.owners.indexOf(owner) === -1</code>判断<code>factory.owners</code>中有没有当前 Vue 实例，若没有，则把当前 Vue 实例添加到<code>factory.owners</code>中。</p>
<p>回到<code>forceRender</code>函数中，执行<code>(owners[i]).$forceUpdate()</code>相当执行<code>vm.$forceUpdate()</code>这个实例方法。这是因为异步组件加载过程中是没有数据发生变化的，所以要通过执行<code>vm.$forceUpdate()</code>迫使 Vue 实例重新渲染一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$forceUpdate</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">_watcher</span>) &#123;</span><br><span class="line">        vm.<span class="property">_watcher</span>.<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>vm._watcher.update()</code>相当执行<code>mountComponent</code>方法中的<code>vm._update(vm._render(), hydrating)</code>，在执行<code>vm._render()</code>过程中调用<code>createComponent</code>方法又执行到以下逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async component</span></span><br><span class="line"><span class="keyword">var</span> asyncFactory</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) &#123;</span><br><span class="line">    asyncFactory = <span class="title class_">Ctor</span></span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(asyncFactory, data, context, children, tag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行<code>resolveAsyncComponent(asyncFactory, baseCtor)</code>时，1000ms已过，故异步组件注册的工厂函数<code>factory</code>中的<code>resolve</code>函数已经执行完毕，故<code>factory.resolved</code>有值，直接返回<code>factory.resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsyncComponent</span>(<span class="params">factory, baseCtor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Promise-异步组件"><a href="#2-Promise-异步组件" class="headerlink" title="2. Promise 异步组件"></a>2. Promise 异步组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./aa.js&#x27;</span>) )</span><br></pre></td></tr></table></figure>

<p><code>resolveAsyncComponent(factory, baseCtor)</code>，参数<code>baseCtor</code>是 Vue 构造函数。参数<code>factory</code>的值就是上面<code>Vue.component</code>的第二参数，返回值是<code>import(&#39;./aa.js&#39;)</code>，它是一个 Promise 对象。整理一下代码，跟此场景无关的代码都去掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsyncComponent</span>(<span class="params">factory, baseCtor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> owner = currentRenderingInstance</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">owners</span>) &amp;&amp; factory.<span class="property">owners</span>.<span class="title function_">indexOf</span>(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">        factory.<span class="property">owners</span>.<span class="title function_">push</span>(owner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !<span class="title function_">isDef</span>(factory.<span class="property">owners</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> owners = factory.<span class="property">owners</span> = [owner]</span><br><span class="line">        <span class="keyword">var</span> sync = <span class="literal">true</span></span><br><span class="line">        (owner).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">remove</span>(owners, owner)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> forceRender = <span class="keyword">function</span>(<span class="params">renderCompleted</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; l = owners.<span class="property">length</span>; i &lt; l i++) &#123;</span><br><span class="line">                (owners[i]).$forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">            <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> reject = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&quot;Failed to resolve async component: &quot;</span> + (<span class="title class_">String</span>(factory)) +</span><br><span class="line">                (reason ? (<span class="string">&quot;\nReason: &quot;</span> + reason) : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">                factory.<span class="property">error</span> = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> res = <span class="title function_">factory</span>(resolve, reject)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isPromise</span>(res)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">                    res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sync = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loading</span> ? factory.<span class="property">loadingComp</span> : factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在此场景中工厂函数<code>factory</code>的返回值是一个 Promise 对象，所以满足<code>isObject(res)</code>和<code>isPromise(res)</code>的条件，执行以下逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">    res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为返回的是 Promise 对象，其实例方法<code>then</code>的参数是两个的函数<code>resolve</code>和<code>reject</code>。当执行成功会执行<code>resolve</code>函数，当执行失败会调用<code>reject</code>函数。</p>
<p>所以这里巧妙地执行<code>res.then(resolve, reject)</code>，当执行成功后会掉<code>resolve</code>函数，而这个<code>resolve</code>函数，是<code>resolveAsyncComponent</code>函数中自定义的。接下来的逻辑就和普通函数异步组件一模一样。</p>
<h2 id="3-高级异步组件"><a href="#3-高级异步组件" class="headerlink" title="3. 高级异步组件"></a>3. 高级异步组件</h2><p>在高级异步组件中，可定义异步组件加载中展示的组件和加载失败展示的组件，对用户更友好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">aa</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">    <span class="comment">// 需要加载的组件。应当是一个 Promise</span></span><br><span class="line">    <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./aa.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 加载中展示的组件</span></span><br><span class="line">    <span class="attr">loading</span>: <span class="title class_">LoadingComp</span>,</span><br><span class="line">    <span class="comment">// 加载失败展示的组件</span></span><br><span class="line">    <span class="attr">error</span>: <span class="title class_">ErrorComp</span>,</span><br><span class="line">    <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms。</span></span><br><span class="line">    <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;aa&#x27;</span>, aa)</span><br></pre></td></tr></table></figure>

<p><code>resolveAsyncComponent(factory, baseCtor)</code>，参数<code>baseCtor</code>是 Vue 构造函数。参数<code>factory</code>的值就是上面<code>Vue.component</code>的第二参数，返回值是一个对象。整理一下代码，跟此场景无关的代码都去掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsyncComponent</span>(<span class="params">factory, baseCtor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">error</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">errorComp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> owner = currentRenderingInstance</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">owners</span>) &amp;&amp; factory.<span class="property">owners</span>.<span class="title function_">indexOf</span>(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">        factory.<span class="property">owners</span>.<span class="title function_">push</span>(owner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">loading</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">loadingComp</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loadingComp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !<span class="title function_">isDef</span>(factory.<span class="property">owners</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> owners = factory.<span class="property">owners</span> = [owner]</span><br><span class="line">        <span class="keyword">var</span> sync = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> timerLoading = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> timerTimeout = <span class="literal">null</span></span><br><span class="line">        (owner).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">remove</span>(owners, owner)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> forceRender = <span class="keyword">function</span>(<span class="params">renderCompleted</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; l = owners.<span class="property">length</span>; i &lt; l i++) &#123;</span><br><span class="line">                (owners[i]).$forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">                    timerLoading = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">                    timerTimeout = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> resolve = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            factory.<span class="property">resolved</span> = <span class="title function_">ensureCtor</span>(res, baseCtor)</span><br><span class="line">            <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owners.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> reject = <span class="title function_">once</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&quot;Failed to resolve async component: &quot;</span> + (<span class="title class_">String</span>(factory)) +</span><br><span class="line">                (reason ? (<span class="string">&quot;\nReason: &quot;</span> + reason) : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">                factory.<span class="property">error</span> = <span class="literal">true</span></span><br><span class="line">                <span class="title function_">forceRender</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> res = <span class="title function_">factory</span>(resolve, reject)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isPromise</span>(res.<span class="property">component</span>)) &#123;</span><br><span class="line">                res.<span class="property">component</span>.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">error</span>)) &#123;</span><br><span class="line">                    factory.<span class="property">errorComp</span> = <span class="title function_">ensureCtor</span>(res.<span class="property">error</span>, baseCtor)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">loading</span>)) &#123;</span><br><span class="line">                    factory.<span class="property">loadingComp</span> = <span class="title function_">ensureCtor</span>(res.<span class="property">loading</span>, baseCtor)</span><br><span class="line">                    <span class="keyword">if</span> (res.<span class="property">delay</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                        factory.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        timerLoading = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                            timerLoading = <span class="literal">null</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>) &amp;&amp; <span class="title function_">isUndef</span>(factory.<span class="property">error</span>)) &#123;</span><br><span class="line">                                factory.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">                                <span class="title function_">forceRender</span>(<span class="literal">false</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, res.<span class="property">delay</span> || <span class="number">200</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isDef</span>(res.<span class="property">timeout</span>)) &#123;</span><br><span class="line">                    timerTimeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        timerTimeout = <span class="literal">null</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(factory.<span class="property">resolved</span>)) &#123;</span><br><span class="line">                            <span class="title function_">reject</span>(</span><br><span class="line">                                <span class="string">&quot;timeout (&quot;</span> + (res.<span class="property">timeout</span>) + <span class="string">&quot;ms)&quot;</span></span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, res.<span class="property">timeout</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sync = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> factory.<span class="property">loading</span> ? factory.<span class="property">loadingComp</span> : factory.<span class="property">resolved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在此场景中工厂函数<code>factory</code>的返回值是一个对象<code>res</code>，</p>
<p>若其中<code>res.component</code>属性是一个 Promise 对象，执行<code>res.component.then(resolve, reject)</code>。</p>
<p>若<code>res.error</code>有值，执行<code>factory.errorComp = ensureCtor(res.error, baseCtor)</code>，把加载失败展示的组件转换成组件构造函数赋值给<code>factory.errorComp</code>。</p>
<p>若<code>res.loading</code>有值，执行<code>factory.loadingComp = ensureCtor(res.loading, baseCtor)</code>，把加载中展示的组件转换成组件构造函数赋值给<code>factory.loadingComp</code>。</p>
<p>若<code>res.delay</code>的值为 0 ，则说明要直接展示加载中的组件，把<code>factory.loading</code>设置为 true 。</p>
<p>若<code>res.delay</code>的值不为 0 ，则说明要经过一段<code>delay</code>时间的延迟才展示加载中的组件，用 setTimeout 定时器在经过一段<code>delay</code>时间的延迟，在异步组件没有加载成功或者失败的情况下把<code>factory.loading</code>设置为 true ，并执行<code>forceRender(false)</code>，触发组件更新的 patch 过程渲染出加载中展示的组件。</p>
<p>若<code>res.timeout</code>有值，用 setTimeout 定时器在在超出<code>res.timeout</code>后异步组件还未加载完成，报错一个超时的错误。</p>
<p>最后如果加载中组件构造函数<code>factory.loading</code>有值返回<code>factory.loading</code>，就不必调用<code>createAsyncPlaceholder</code>方法创建注释节点来作为占位节点，直接用加载中展示的组件生成的 DOM 节点来作为占位节点。</p>
<p>异步组件是在组件更新的 patch 过程才渲染的，会再调用<code>resolveAsyncComponent</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">error</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">errorComp</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.<span class="property">errorComp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isTrue</span>(factory.<span class="property">loading</span>) &amp;&amp; <span class="title function_">isDef</span>(factory.<span class="property">loadingComp</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.<span class="property">loadingComp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若<code>factory.error</code>为true且加载失败组件构造函数<code>factory.errorComp</code>存在，返回<code>factory.errorComp</code>。</p>
<p>若<code>factory.loading</code>为true且加载中组件构造函数<code>factory.loadingComp</code>存在，返回<code>factory.loadingComp</code>。</p>
<p>异步组件加载成功返回<code>factory.resolved</code>，接下来的逻辑就和普通函数异步组件一模一样。</p>
<p>最后在介绍一下异步组件加载失败时处理，其会调用自定义的<code>reject</code>函数，若<code>factory.errorComp</code>，把<code>factory.error</code>置为true。然后执行<code>forceRender(true)</code>，此时其参数为true，在强制重新渲染中可以把加载中和加载超时中的定时器清空。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vue 的异步组件有 3 种实现方式，其中高级异步组件实现了loading、resolve、reject、timeout 4 种状态。异步组件实现的本质是 2 次渲染，除了<code>delay</code>为 0 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步加载组件成功后，执行<code>resolve</code>函数，在其中调用<code>forceRender</code>函数强制重新渲染，第二次调用<code>resolveAsyncComponent</code>函数，返回真正的组件构造函数<code>factory.resolved</code>，再通过组件更新的 patch 过程就能渲染出异步组件了。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue循环中key的作用</title>
    <url>/2021/01/12/vue/vue%E5%BE%AA%E7%8E%AF%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><ul>
<li><strong>预期</strong>：<code>number | string | boolean (2.4.2 新增) | symbol (2.5.12 新增)</code></li>
</ul>
<p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p>
<p>最常见的是结合 <code>v-for</code> 使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>当<code>text</code>发生改变时，<code>&lt;span&gt;</code>总是会被替换而不是被修改，因此会引发过渡。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽</title>
    <url>/2021/01/29/vue/vue%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h1><p><strong>作用：</strong> 为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。</p>
<h1 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a>插槽的基本使用</h1><ol>
<li>在组件中定义一个<code>&lt;slot&gt;&lt;/slot&gt;</code>标签即可</li>
<li>如果插槽内具有共性的东西较多，可在插槽内设置默认值，当没有在插槽传入值时显示默认值</li>
<li>如果有多个值，同时放入到组件中进行替换时，一起作为替换元素</li>
</ol>
<h2 id="1-匿名插槽"><a href="#1-匿名插槽" class="headerlink" title="1. 匿名插槽"></a>1. 匿名插槽</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mainview</span>&gt;</span><span class="tag">&lt;/<span class="name">mainview</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>插槽默认值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// view注册为一个局部组件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">mainview</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">template</span>: <span class="string">&quot;#view&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行这段代码，组件会渲染<slot></slot>插槽里的默认内容。想要覆盖默认内容，只需要在组件中插入你需要显示的内容即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mainview</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: #42B983;&quot;</span>&gt;</span></span><br><span class="line">		修改插槽</span><br><span class="line">	<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mainview</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改之后，渲染的内容就会变成了我们在 <code>mainview</code> 中定义的内容。</p>
<p>这就是插槽 <code>&lt;slot&gt;</code> 一个基本使用，还是比较好理解的。</p>
<h2 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h2><p>假设我们要做一个博客页面，这个页面分为三个部分头部<code>header</code>, 内容<code>main</code>，底部<code>footer</code>，这三个模块我们都通过插槽来实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 引用插槽 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是头部header插槽内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是默认插槽的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>这是footer插槽内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">      <span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 定义组件间模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 定义具名插槽 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 局部注册组件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">BaseLayout</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">template</span>: <span class="string">&quot;#layout&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在layout组件中定义了三个插槽，其中header和footer通过slot的name属性制定了插槽的名称，main用一个默认插槽填充，其中header和footer两个具名插槽会精确地匹配 name传入相应的插槽，任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>
<p><strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> ，并且可以缩写为一个<code>#</code>，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<h2 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h2><p>作用域插槽就是在子组件预定义一个区块，之后想插入什么右父组件决定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">current-user</span>&gt;</span><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义CurrentUser组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123; user.LastName &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">CurrentUser</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">template</span>:<span class="string">&quot;#account&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">user</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">fristName</span>: <span class="string">&quot;刘&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">lastName</span>: <span class="string">&quot;德华&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先我们定义了一个 <code>&lt;current-user&gt;</code> 的组件，这个组件的模板中定义了一个默认插槽并设置了一个初始值 <code>&#123;&#123; user.lastName &#125;&#125;</code>，运行这段代码会看到如期渲染除了组建中传入的 <code>lastName</code> 的值，如果这个名字不让显示了，只让显示一个姓就行了，但是要在父组件中调用子组件的 frstName 覆盖掉插槽默认传入的 lastName 要怎么做呢？这时候就是作用域插槽出场的时候了！</p>
<p>首先，我们必须把子组件的user作为slot的元素属性通过v-bind绑定上去才可以，这个绑定在 <code>&lt;slot&gt;</code> 元素上的 属性 （user）被称为<strong>插槽 prop</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	&#123;&#123; user.lastName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">          &#123;&#123; slotProps.user.fristName &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果当我们提供的组件模板中有且仅有一个默认插槽时</strong>，组件的标签可以被当做插槽的模板使用，<strong>但是，默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确！</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123; slotProps.user.fristName &#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">template</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2020/12/17/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/1d37d5e068a3b9a337d1c4f9a2def7f3.png" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="生命周期有8个函数（钩子）："><a href="#生命周期有8个函数（钩子）：" class="headerlink" title="生命周期有8个函数（钩子）："></a>生命周期有8个函数（钩子）：</h2><p><strong>1. beforeCreate 创建前</strong></p>
<blockquote>
<p>在实例初始化之后，数据观测（data observer）和 event/watch事件配置之前被调用</p>
</blockquote>
<p>一般这个时候，对象还没有创建，组件还没有挂载，data等还没有初始化，一般用来在组件挂载前渲染一些东西</p>
<p><strong>2. Created 创建完成</strong></p>
<blockquote>
<p>在实例创建完成后立即被调用，在这一步实例已经完成了：数据观测、属性和方法的运算和 event/watch事件的回调，但是$el属性目前不可见。</p>
</blockquote>
<p>这时候上面的data、methods、computed都已经创建完成了，可以调用methods中的方法，改变data中的数据</p>
<p><strong>3. beforeMount 挂载前</strong></p>
<blockquote>
<p>在挂载开始之前被调用</p>
</blockquote>
<p>挂载之前被调用，render（渲染）函数首次被调用，但还没有渲染到页面上</p>
<p><strong>4. mounted</strong> 挂载完成</p>
<blockquote>
<p>在挂载成功后被调用，el被新创建的vm.$el替换</p>
</blockquote>
<p>挂载完成了，这时候HTML模板会被渲染到HTML中。但mounted只能执行一次。</p>
<p><strong>5. beforeUpdate 更新前</strong></p>
<blockquote>
<p>数据更新之前调用</p>
</blockquote>
<p>更新指数据更新，发生在虚拟DOM重新渲染之前，在这个钩子中可以更改状态而不发生重绘。</p>
<p><strong>6. updated 更新完成</strong></p>
<blockquote>
<p>数据更新完成时调用，组件dom已经更新</p>
</blockquote>
<p>调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p>
<p><strong>7. beforeDestroy 销毁前</strong></p>
<blockquote>
<p>组件销毁前调用</p>
</blockquote>
<p>在实例销毁前调用，一般用来做重置操作，比如清除定时器和DOM监听事件。</p>
<p><strong>8. destroyed 销毁完成</strong></p>
<blockquote>
<p>组件销毁后调用</p>
</blockquote>
<p>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</p>
<h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><h5 id="1-什么是vue生命周期？"><a href="#1-什么是vue生命周期？" class="headerlink" title="1. 什么是vue生命周期？"></a>1. 什么是vue生命周期？</h5><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-渲染、更新-渲染、卸载等一系列的过程，我们称这是 Vue 的生命周期。</p>
<h5 id="2-vue生命周期的作用是什么"><a href="#2-vue生命周期的作用是什么" class="headerlink" title="2. vue生命周期的作用是什么"></a>2. vue生命周期的作用是什么</h5><p>Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。 生命周期中有多个事件钩子，在控制整个vue实例的过程时更容易形成好的逻辑。</p>
<h5 id="3-第一次页面加载会触发哪几个钩子？"><a href="#3-第一次页面加载会触发哪几个钩子？" class="headerlink" title="3. 第一次页面加载会触发哪几个钩子？"></a>3. 第一次页面加载会触发哪几个钩子？</h5><p>beforeCreate ， created ， beforeMount ，mounted 这几个钩子</p>
<h5 id="4-父子组件的生命周期"><a href="#4-父子组件的生命周期" class="headerlink" title="4. 父子组件的生命周期"></a>4. 父子组件的生命周期</h5><ul>
<li>执行顺序：<ul>
<li>父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。</li>
<li>如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。</li>
</ul>
</li>
<li>当子组件挂载完成后，父组件才会挂载。</li>
<li>当子组件完成挂在后，父组件会主动执行一次beforeUpdated/updated钩子函数（仅首次）</li>
<li>父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。</li>
<li>销毁父组件时，先将子组件销毁后才会销毁父组件。</li>
<li>兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行</li>
<li>当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/2021/01/28/vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="1-history模式，页面返回404，如何解决？"><a href="#1-history模式，页面返回404，如何解决？" class="headerlink" title="1. history模式，页面返回404，如何解决？"></a>1. history模式，页面返回404，如何解决？</h1><p>history是html5的新增api，它的功能是修改地址栏但是不向服务器发送真实请求。如果页面返回404，说明发送了请求到服务器端，但是服务器端对该请求没有做处理，解决方案就是服务器端对于这类请求重定向到某个页面即可。</p>
<h1 id="2-commonjs规范"><a href="#2-commonjs规范" class="headerlink" title="2. commonjs规范"></a>2. commonjs规范</h1><p>  node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。</p>
<h2 id="CommonJS模块的特点"><a href="#CommonJS模块的特点" class="headerlink" title="CommonJS模块的特点"></a>CommonJS模块的特点</h2><p>所有代码都运行在模块作用域，不会污染全局作用域。</p>
<p>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</p>
<p>模块加载的顺序，按照其在代码中出现的顺序。</p>
<h2 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h2><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>
<h2 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h2><p>基本用法  require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错。</p>
<h1 id="3-vue指令以及作用"><a href="#3-vue指令以及作用" class="headerlink" title="3. vue指令以及作用"></a>3. vue指令以及作用</h1><p>在模板中可以通过指令直接访问data和methods中的属性方法</p>
<p><strong>1. 分类：</strong> 指令可以写在标签上(<code>&lt;span 指令&gt;&lt;/span&gt;</code>)或写在标签中间(<code>&lt;span&gt;指令&lt;/span&gt;</code>)</p>
<p><strong>2. 插值：</strong> 可以再<code>&#123;&#123;&#125;&#125;</code>中写js表达式 (一个普通变量、函数调用、逻辑表达式、三目运算…)，写在开标签和闭合标签中间</p>
<p><strong>3. 指令：</strong></p>
<ul>
<li><p><strong>v-text：</strong> 与<code>&#123;&#123;&#125;&#125;</code>含义相同</p>
</li>
<li><p><strong>v-html：</strong> 插入字符串，解析 html</p>
</li>
<li><p><strong>v-show：</strong> 根据表达式的值，<strong>切换元素的display的值</strong></p>
</li>
<li><p><strong>v-if：</strong> 根据表达式<strong>有条件渲染元素</strong></p>
<p><strong>v-show 处理的是频繁切换显示与隐藏的dom，反之则 v-if</strong></p>
</li>
<li><p><strong>v-else-if</strong></p>
</li>
<li><p><strong>v-else</strong></p>
</li>
<li><p><strong>v-for：</strong> 基于源数据多次渲染元素或模板块</p>
</li>
<li><p><strong>v-bind：</strong> 动态绑定html属性</p>
<p>语法：**(1) v-bind:属性名=”属性值”**</p>
<pre><code>   **(2) :属性名=&quot;属性值&quot;****
</code></pre>
</li>
<li><p><strong>v-on:</strong> 事件监听</p>
<p>语法：**(1) v-on事件名=”函数名”**</p>
<pre><code>  **(2)@事件名=&quot;函数名&quot;**
</code></pre>
<p>修饰符：</p>
<p><strong>.stop</strong> -调用event.stopPropagation( ) </p>
<p><strong>.prevent</strong> -调用event.preventDefault( ) </p>
<p><strong>.capture</strong> -添加事件侦听器时使用capture模式</p>
<p><strong>.self</strong> -只当事件是从侦听器绑定的元素本身触发时才触发回调</p>
<p><strong>.{keyCode | keyAlias}</strong> -只当事件是从特定键触发时才触发回调</p>
<p><strong>.native</strong> -监听组件根元素的原生事件</p>
<p><strong>.once</strong> -只触发—次回调.left -(2.2.0)只当点击鼠标左键时触发</p>
<p><strong>.right</strong> -(2.2.0)只当点击鼠标右键时触发</p>
<p><strong>.middle</strong> -(2.2.0)只当点击鼠标中键时触发</p>
<p><strong>.passive</strong> -(2.3.0)以{ passive: true }模式添加侦听器</p>
</li>
<li><p><strong>v-model：</strong> 在表单控件或者组件上双向绑定</p>
<p>语法： <strong>(1) v-model=”变量名”</strong></p>
<p>修饰符：</p>
<p><strong>.lazy</strong> - 取代 <code>input</code> 监听 <code>change</code> 事件</p>
<p><strong>.number</strong> - 输入字符串转为有效的数字</p>
<p><strong>.trim</strong> - 输入首尾空格过滤</p>
</li>
</ul>
<h1 id="4-EventBus"><a href="#4-EventBus" class="headerlink" title="4. EventBus"></a>4. <code>EventBus</code></h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>​    <code>EventBus</code> 又称为事件总线。在 vue 中可以使用 <code>EventBus</code> 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的灾难，因此才需要更完善的 vuex 作为状态管理中心，将通知的概念上升到共享状态层次。</p>
<h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>​    首先在main.js中输入 var bus=new Vue() Vue.prototype.$bus=bus 然后 在a组件中输入this.$bus.$emit(‘自定义事件名’，”参数”) 然后在接收参数的b组件中输入this.$bus.$on(‘自定义事件名’,’参数’)</p>
<h1 id="5-vue-router-的原理-history、hash"><a href="#5-vue-router-的原理-history、hash" class="headerlink" title="5. vue-router 的原理 (history、hash)"></a>5. vue-router 的原理 (history、hash)</h1><h2 id="vue-router是什么？"><a href="#vue-router是什么？" class="headerlink" title="vue-router是什么？"></a>vue-router是什么？</h2><p>实现更新视图但不重新加载页面。url与页面一一对应</p>
<p><strong>路由跳转两种方式</strong></p>
<ol>
<li><p>声明式：通过<router-link></router-link>组件进行跳转，<router-view />显示。</p>
</li>
<li><p>编程式：通过路由实例进行跳转： this.$router</p>
<p>this.$router.push(“url”)</p>
<p>this.$router.push({path: ‘url’})</p>
<p>this.$router.push({name: ‘routeName’, params: {id: 1}})</p>
<p>this.$router.push({psth: ‘url’, query: {id: 1}})</p>
<p>**注意： params与path不能同时出现 **</p>
</li>
</ol>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><ol>
<li>形如： localhost:8080/#/home/index</li>
<li>原理： #后面 hash 值的变化，并不会导致浏览器向服务器发送请求，也不会刷新页面。每次 hash 值发生变化，会触发 <code>hashchange</code> 这个事件，可以通过监听 <code>hashchange</code> 事件得知 hash 值发生了哪些变化，并更新页面部分内容。</li>
<li>缺点： 兼容性不好，部分低版本IE浏览器无 <code>hashchange</code> 这个事件。</li>
</ol>
<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><ol>
<li>形如： localhost:8080/home/index</li>
<li>原理，因为 html5 的发布，多了两个api， <code>pushState()</code> 和 <code>replaceState()</code> 。通过这两个api (1)可以改变 url 地址且不发送请求，(2)不仅可以读取历史记录栈，还可以对浏览器历史记录栈进行更改。</li>
<li>缺点： 怕刷新，刷新会向后端发送请求。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>组件动态渲染</title>
    <url>/2021/11/22/vue/%E7%BB%84%E4%BB%B6%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>目前有一个需求是：通过接口获取组件位置并进行渲染，位置是固定的，但模块可能会不同，<br>将目录 dir 下的组件渲染到 index.vue 上，常规做法是在 index.vue 中直接引入注册<br>目录结构：<br>├─ dir<br>    ├─ comp1.vue<br>    ├─ comp2.vue<br>    └─ …<br>└─ index.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> comp1 <span class="keyword">from</span> <span class="string">&#x27;./dir/comp1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> comp2 <span class="keyword">from</span> <span class="string">&#x27;./dir/comp2.vue&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    comp1,</span><br><span class="line">    comp2</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果组件多可以通过或者获取文件名来进行组件注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sections = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;./dir&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.vue$/</span>)</span><br><span class="line">files.<span class="title function_">keys</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> component = <span class="title function_">files</span>(key).<span class="property">default</span></span><br><span class="line">  sections[component.<span class="property">name</span>] = component</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    ...sections</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将组件渲染到页面上，可以通过动态遍历进行动态注册并渲染</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过 <component :is="app"> 进行动态渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 通过循环渲染，在 :is=&quot;&quot; 中进行判断，例如判断 id， 如果没有符合的值 is 的值就为空，页面上就不会展示组件  --&gt;</span><br><span class="line">    &lt;component :is=&quot;item.id === 1 ? item.component : &#x27;&#x27;&quot; v-for=&quot;item in comps&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      comps: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getComps() &#123;</span><br><span class="line">      const data = &#x27;接口返回的数据&#x27;</span><br><span class="line">      data.forEach(item =&gt; &#123;</span><br><span class="line">        this.comps.push(&#123; id: item.id, component: item.component &#125;) // [&#123; id: 1, component: &#x27;comps1&#x27; &#125;, &#123; id: 2, component: &#x27;comps2&#x27; &#125;... ]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>相关文档：<a href="https://zhuanlan.zhihu.com/p/35535469">https://zhuanlan.zhihu.com/p/35535469</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>不以by小经验</tag>
      </tags>
  </entry>
  <entry>
    <title>word、Excel、PDF、TXT预览（Vue项目）</title>
    <url>/2022/07/04/vue/%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Vue项目要在内网环境进行预览，pdf可以直接使用浏览器自带的方式进行预览，但是word和excel需要借助插件，预览本地文件，或者是内网文件，可以使用以下方法进行预览：</p>
<p>Word: docx-preview</p>
<p>Excel: SheetJS</p>
<p>PDF：vue-pdf</p>
<p>txt: iframe</p>
<h2 id="word预览"><a href="#word预览" class="headerlink" title="word预览"></a>word预览</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i docx-preview@0.1.4</span><br><span class="line">npm i jszip</span><br></pre></td></tr></table></figure>
<h3 id="预览在线地址文件"><a href="#预览在线地址文件" class="headerlink" title="预览在线地址文件"></a>预览在线地址文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;div ref=&quot;file&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">const docx = require(&#x27;docx-preview&#x27;)</span><br><span class="line"></span><br><span class="line">// 如果 docx-preview 版本比较新需要 es6 导出</span><br><span class="line">// import &#123; renderAsync &#125; from &#x27;docx-preview&#x27;</span><br><span class="line"></span><br><span class="line">window.JSZip = require(&#x27;jszip&#x27;)</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      method: &#x27;get&#x27;,</span><br><span class="line">      responseType: &#x27;blob&#x27;, // 设置响应文件格式</span><br><span class="line">      url: &#x27;/docx&#x27;,</span><br><span class="line">    &#125;).then((&#123;data&#125;) =&gt; &#123;</span><br><span class="line">      docx.renderAsync(data,this.$refs.file) // 渲染到页面预览</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="预览本地文件"><a href="#预览本地文件" class="headerlink" title="预览本地文件"></a>预览本地文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;my-component&quot; ref=&quot;preview&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;preview&quot; ref=&quot;file&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">const docx = require(&#x27;docx-preview&#x27;);</span><br><span class="line">window.JSZip = require(&#x27;jszip&#x27;)</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    preview(e)&#123;</span><br><span class="line">      docx.renderAsync(this.$refs.file.files[0],this.$refs.preview) // 渲染到页面预览</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.my-component&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 90vh;</span><br><span class="line">  border: 1px solid #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="excel预览"><a href="#excel预览" class="headerlink" title="excel预览"></a>excel预览</h2><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save xlsx</span><br></pre></td></tr></table></figure>

<h3 id="excel-vue"><a href="#excel-vue" class="headerlink" title="excel.vue"></a>excel.vue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;table&quot;&gt;</span><br><span class="line">    &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        v-for=&quot;(key,index) in tableHeader&quot;</span><br><span class="line">        :key=&quot;index&quot;</span><br><span class="line">        :prop=&quot;key&quot;</span><br><span class="line">        :label=&quot;key&quot;</span><br><span class="line">      &gt;&lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import XLSX from &#x27;xlsx&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tableData: [],</span><br><span class="line">      tableHeader: [],</span><br><span class="line">      workbook: &#123;&#125;,</span><br><span class="line">      excelURL: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.excelURL = this.$route.query.excelURL</span><br><span class="line">    this.readWorkbookFromRemoteFile(this.excelURL)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    readWorkbookFromRemoteFile(url) &#123;</span><br><span class="line">      var xhr = new XMLHttpRequest()</span><br><span class="line">      xhr.open(&#x27;get&#x27;, url, true)</span><br><span class="line">      xhr.responseType = &#x27;arraybuffer&#x27;</span><br><span class="line">      let _this = this</span><br><span class="line">      xhr.onload = function(e) &#123;</span><br><span class="line">        if (xhr.status === 200) &#123;</span><br><span class="line">          var data = new Uint8Array(xhr.response)</span><br><span class="line">          var workbook = XLSX.read(data, &#123; type: &#x27;array&#x27; &#125;)</span><br><span class="line"></span><br><span class="line">          var sheetNames = workbook.SheetNames; // 工作表名称集合</span><br><span class="line">          _this.workbook = workbook;</span><br><span class="line">          _this.getTable(sheetNames[0])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      xhr.send()</span><br><span class="line">    &#125;,</span><br><span class="line">    getTable(sheetName) &#123;</span><br><span class="line">      var worksheet = this.workbook.Sheets[sheetName]</span><br><span class="line">      this.tableData = XLSX.utils.sheet_to_json(worksheet)</span><br><span class="line"></span><br><span class="line">      this.tableHeader = []</span><br><span class="line">      if (this.tableData.length &gt; 0) &#123;</span><br><span class="line">        for (var i in this.tableData[0]) &#123;</span><br><span class="line">          this.tableHeader.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#table &#123;</span><br><span class="line">  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  border: 1px solid #ebebeb;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  width: 80%;</span><br><span class="line">  margin: 20px auto;</span><br><span class="line">  border-shadow: 0 0 8px 0 rgba(232, 237, 250, 0.6), 0 2px 4px 0 rgba(232, 237, 250, 0.5);</span><br><span class="line">  border-radius: 10px;</span><br><span class="line">  overflow: scroll;</span><br><span class="line">  height: 100%;</span><br><span class="line"></span><br><span class="line">  .tab &#123;</span><br><span class="line">    margin: 0 0 20px 0;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: row;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.is-active &#123;</span><br><span class="line">  background-color: #409eff;</span><br><span class="line">&#125;</span><br><span class="line">span &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="pdf预览"><a href="#pdf预览" class="headerlink" title="pdf预览"></a>pdf预览</h2><h3 id="安装依赖-2"><a href="#安装依赖-2" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save vue-pdf</span><br></pre></td></tr></table></figure>
<h3 id="pdf-vue"><a href="#pdf-vue" class="headerlink" title="pdf.vue"></a>pdf.vue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;pdf ref=&quot;pdf&quot; :src=&quot;pdfUrl&quot; style=&quot;width:100%;&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pdf from &#x27;vue-pdf&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return: &#123;</span><br><span class="line">      pdfUrl: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  created() &#123;</span><br><span class="line">    const path = &#x27;test.pdf&#x27;// 你获取到的pdf路径</span><br><span class="line">    // pdf.createLoadingTask解决文件件跨域问题</span><br><span class="line">    this.pdfUrl = pdf.createLoadingTask(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="txt预览"><a href="#txt预览" class="headerlink" title="txt预览"></a>txt预览</h2><h3 id="txt-vue"><a href="#txt-vue" class="headerlink" title="txt.vue"></a>txt.vue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;iframe :src=&quot;fileurl&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;600&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>预览文件</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中loader的使用方法</title>
    <url>/2021/01/18/webpack/webpack%E4%B8%ADloader%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p><code>loader</code> 用于对模块的源代码进行转换。 <code>loader</code> 可以使你在 <code>import</code> 或“加载”模块是预处理文件。loader 可以将文件从不同的语言转换为 JavaScript。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先安装相对应的 loader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br><span class="line">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure>

<p>然后指示 webpack 对每个 <code>.css</code> 使用 <code>css-loader</code>，以及对所有 <code>.ts</code> 文件使用 <code>ts-loader</code>：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用-loader"><a href="#使用-loader" class="headerlink" title="使用 loader"></a>使用 loader</h2><p>在你的应用程序中，有三种使用 loader 的方式：</p>
<ul>
<li>配置（推荐）：在 <strong>webpack.config.js</strong> 文件中指定 loader。</li>
<li>内联：在每个 <code>import</code> 语句中显式指定 loader。</li>
</ul>
<h3 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置[Configuration]"></a>配置[Configuration]</h3><p><code>module.rules</code> 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>可以在 <code>import</code> 语句或任何等效于 “import” 的方式中指定 loader。使用 <code>!</code> 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过前置所有规则及使用 <code>!</code>，可以对应覆盖到配置中的任意 loader。</p>
<blockquote>
<p><em>尽可能使用</em> <code>module.rules</code><em>，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</em></p>
</blockquote>
<h2 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h2><ul>
<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>
<li>loader 接收查询参数。用于对 loader 传递配置。</li>
<li>loader 也能够使用 <code>options</code> 对象进行配置。</li>
<li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性，还可以将普通的 npm 模块导出为 loader，做法是在 <code>package.json</code> 里定义一个 <code>loader</code> 字段。</li>
<li>插件( plugin )可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<p>loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。</p>
<h2 id="解析-loader"><a href="#解析-loader" class="headerlink" title="解析 loader"></a>解析 loader</h2><p>loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 <code>npm install</code>, <code>node_modules</code>）解析。</p>
<p>loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 <code>xxx-loader</code>（例如 <code>json-loader</code>）。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器存储cookies、session、sessionStorage和localStorage解释及区别</title>
    <url>/2020/12/22/window/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8cookies%E3%80%81session%E3%80%81sessionStorage%E5%92%8ClocalStorage%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://img-blog.csdnimg.cn/20201222191802658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGFuaWVfd3U=,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动" loading="lazy"></p>
<h2 id="一、cookie，session"><a href="#一、cookie，session" class="headerlink" title="一、cookie，session"></a>一、cookie，session</h2><p>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互。</p>
<p>cookie和session都是用来跟踪浏览器用户的身份的方式</p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h3><p><strong>1.保存方式</strong></p>
<p>cookie保存在浏览器端</p>
<p>session保存在服务器端</p>
<p><strong>2.使用方法</strong></p>
<p>cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p>
<p>session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。</p>
<p><strong>3、存储内容：</strong></p>
<p>cookie只能保存字符串类型，以文本的方式。</p>
<p>session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</p>
<p><strong>4、存储的大小：</strong></p>
<p>cookie：单个cookie保存的数据不能超过4kb。</p>
<p>session大小没有限制。</p>
<p><strong>5、安全性：</strong></p>
<p>cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。</p>
<p><strong>6、应用场景：</strong></p>
<p>cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>
<p>　　　　（2）保存上次登录的时间等信息。</p>
<p>　　　　（3）保存上次查看的页面</p>
<p>　　　　（4）浏览计数</p>
<p>session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。</p>
<p>　　   （1）网上商城中的购物车</p>
<p>　　   （2）保存用户登录信息</p>
<p>　　   （3）将某些数据放入session中，供同一用户的不同页面使用</p>
<p>　　   （4）防止用户非法登录</p>
<p>7、缺点：</p>
<p>cookie：（1）大小受限</p>
<p>　　　　（2）用户可以操作（禁用）cookie，使功能受限</p>
<p>　　　　（3）安全性较低</p>
<p>　　　　（4）有些状态不可能保存在客户端。</p>
<p>　　　　（5）每次访问都要传送cookie给服务器，浪费带宽。</p>
<p>　　　　（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
<p>session：（1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>
<p>　　　　 （2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</p>
<p>　　　　 （3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p>
<h2 id="二、SessionStorage，LocalStorage"><a href="#二、SessionStorage，LocalStorage" class="headerlink" title="二、SessionStorage，LocalStorage"></a>二、SessionStorage，LocalStorage</h2><p>SessionStorage,LocalStorage和cookie这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。 区别在于前两者属于WebStorage，创建它们的目的便于客户端存储数据。</p>
<p>Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。</p>
<h2 id="sessionStorage："><a href="#sessionStorage：" class="headerlink" title="sessionStorage："></a>sessionStorage：</h2><p>将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。</p>
<h2 id="localStorage："><a href="#localStorage：" class="headerlink" title="localStorage："></a>localStorage：</h2><p>将数据保存在客户端本地中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p>
<p><strong>目标：</strong></p>
<p>1、提供一种在cookie之外存储会话数据的路径。</p>
<p>2、提供一种存储大量可以跨会话存在的数据的机制。</p>
<h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a><strong>区别：</strong></h3><p>sessionStorage为临时保存，而localStorage为永久保存。</p>
<p><strong>1、生命周期：</strong></p>
<p>　　　localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p>
<p>　　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p>
<p><strong>2、存储大小：</strong>localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p><strong>3、存储位置：</strong>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。</p>
<p><strong>4、存储内容类型：</strong>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p><strong>5、获取方式：</strong>localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。<strong>6、应用场景：</strong>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p><strong>存储空间更大：</strong>cookie为4KB，而WebStorage是5MB；</p>
<p><strong>节省网络流量：</strong>WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；</p>
<p><strong>快速显示：</strong>有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；</p>
<p><strong>安全性：</strong>WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；</p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>JavaScript</tag>
        <tag>session</tag>
        <tag>cookie</tag>
        <tag>浏览器机制</tag>
      </tags>
  </entry>
  <entry>
    <title>环形图/圆角环形图</title>
    <url>/2021/08/30/Echarts/%E7%8E%AF%E5%BD%A2%E5%9B%BE/%E5%9C%86%E8%A7%92%E7%8E%AF%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>由于在项目中需要对数据进行可视化，也就是用图表展示，常用的图表插件有echarts，highcharts，这里选择了比较大众化的echarts。</p>
<p>所有的数据都是动态获取的，由前端向后台请求。当然请求数据肯定不会放在图表组件中，而是放在了外部。所以可以封装成组件，使用时向图表传递数据。</p>
<h3 id="安装-echarts-依赖"><a href="#安装-echarts-依赖" class="headerlink" title="安装 echarts 依赖"></a>安装 echarts 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install echarts -S</span><br><span class="line"></span><br><span class="line">// 或者使用淘宝的镜像</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install echarts -S</span><br></pre></td></tr></table></figure>

<h3 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h3><p>首先需要全局引入<br>在 main.js 中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 echarts</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$echarts</span> = echarts</span><br></pre></td></tr></table></figure>

<p>创建组件 echarts.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;className&quot; :style=&quot;&#123;height:height,width:width&#125;&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="静态写法"><a href="#静态写法" class="headerlink" title="静态写法"></a>静态写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title class_">PieChart</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title class_">PieChart</span>() &#123;</span><br><span class="line">      <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span><br><span class="line">      <span class="keyword">let</span> myChart = <span class="variable language_">this</span>.<span class="property">$echarts</span>.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myChart&#x27;</span>))</span><br><span class="line">      <span class="comment">// 绘制图表</span></span><br><span class="line">      myChart.<span class="title function_">setOption</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: &#123; <span class="attr">text</span>: <span class="string">&#x27;在Vue中使用echarts&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">tooltip</span>: &#123;</span><br><span class="line">          <span class="attr">trigger</span>: <span class="string">&#x27;item&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">legend</span>: &#123;</span><br><span class="line">          <span class="attr">top</span>: <span class="string">&#x27;5%&#x27;</span>,</span><br><span class="line">          <span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">series</span>: [&#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;访问来源&#x27;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">          <span class="attr">radius</span>: [<span class="string">&#x27;40%&#x27;</span>, <span class="string">&#x27;70%&#x27;</span>],</span><br><span class="line">          <span class="attr">avoidLabelOverlap</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">            <span class="attr">borderRadius</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">borderColor</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">            <span class="attr">borderWidth</span>: <span class="number">2</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">label</span>: &#123;</span><br><span class="line">            <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">position</span>: <span class="string">&#x27;center&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">emphasis</span>: &#123;</span><br><span class="line">            <span class="attr">label</span>: &#123;</span><br><span class="line">              <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">fontSize</span>: <span class="string">&#x27;40&#x27;</span>,</span><br><span class="line">              <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">labelLine</span>: &#123;</span><br><span class="line">            <span class="attr">show</span>: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">data</span>: [</span><br><span class="line">            &#123;<span class="attr">value</span>: <span class="number">1048</span>, <span class="attr">name</span>: <span class="string">&#x27;搜索引擎&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">value</span>: <span class="number">735</span>, <span class="attr">name</span>: <span class="string">&#x27;直接访问&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">value</span>: <span class="number">580</span>, <span class="attr">name</span>: <span class="string">&#x27;邮件营销&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">value</span>: <span class="number">484</span>, <span class="attr">name</span>: <span class="string">&#x27;联盟广告&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">value</span>: <span class="number">300</span>, <span class="attr">name</span>: <span class="string">&#x27;视频广告&#x27;</span>&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/Echarts/pie.jpg?raw=true" alt="pie" loading="lazy"></p>
<h4 id="动态写法"><a href="#动态写法" class="headerlink" title="动态写法"></a>动态写法</h4><p>动态写法和静态的不同在于动态渲染数据，所以数据不能写死，需要在获取数据后渲染图表，获取数据分为两种，一种是调取接口获取，一种是通过父级传递</p>
<h5 id="获取接口渲染"><a href="#获取接口渲染" class="headerlink" title="获取接口渲染"></a>获取接口渲染</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">showed</span>: <span class="literal">false</span>, <span class="comment">// option 中 title 是否展示开关</span></span><br><span class="line">      <span class="attr">chart</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">legend</span>: [],</span><br><span class="line">      <span class="attr">series</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">options</span>(<span class="params"></span>) &#123; <span class="comment">// 将图表的配置写在 computed 中，将需要动态渲染的值留空</span></span><br><span class="line">      <span class="keyword">const</span> option = &#123;</span><br><span class="line">        <span class="attr">title</span>: &#123;</span><br><span class="line">          <span class="attr">show</span>: <span class="variable language_">this</span>.<span class="property">showed</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&#x27;暂无数据&#x27;</span>,</span><br><span class="line">          <span class="attr">x</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">y</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">textStyle</span>: &#123;</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;#909399&#x27;</span>,</span><br><span class="line">            <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">            <span class="attr">fontSize</span>: <span class="number">14</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">tooltip</span>: &#123;</span><br><span class="line">          <span class="attr">trigger</span>: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">          <span class="attr">backgroundColor</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">          <span class="attr">formatter</span>: <span class="string">&#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">legend</span>: &#123;</span><br><span class="line">          <span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">bottom</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">series</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;访问来源&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">            <span class="attr">roseType</span>: <span class="string">&#x27;radius&#x27;</span>,</span><br><span class="line">            <span class="attr">radius</span>: [<span class="number">15</span>, <span class="number">95</span>],</span><br><span class="line">            <span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;38%&#x27;</span>],</span><br><span class="line">            <span class="attr">animationEasing</span>: <span class="string">&#x27;cubicInOut&#x27;</span>,</span><br><span class="line">            <span class="attr">animationDuration</span>: <span class="number">2600</span>,</span><br><span class="line">            <span class="attr">data</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> option</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getChartData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getChartData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = response.<span class="property">response</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">length</span>) &#123; <span class="comment">// 判断 data 有没有数据，当 data 有数据时给图表赋值</span></span><br><span class="line">          data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">legend</span>.<span class="title function_">push</span>(item.<span class="property">cate_name</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">series</span>.<span class="title function_">push</span>(&#123; <span class="attr">value</span>: item.<span class="property">total</span>, <span class="attr">name</span>: item.<span class="property">cate_name</span> &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">legend</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">legend</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">series</span>[<span class="number">0</span>].<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">series</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">showed</span> = <span class="literal">false</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">initChart</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">showed</span> = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">initChart</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">chart</span> = <span class="variable language_">this</span>.<span class="property">$echarts</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="string">&#x27;macarons&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">chart</span>.<span class="title function_">setOption</span>(<span class="variable language_">this</span>.<span class="property">options</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="父级传参渲染"><a href="#父级传参渲染" class="headerlink" title="父级传参渲染"></a>父级传参渲染</h5><p>父级传参可能会遇到一个页面使用多个饼图图表，此时你会发现：如果还按照上面这种写法会出现只有一个图表宽高不是默认的问题，所以可以每一次都重新定义图表的配置项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;chart&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">width</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;100%&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">height</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;300px&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;漏洞&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">chartData</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123; [] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">chart</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">chartData</span>: &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度监听数据是否发生变化</span></span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setOptions</span>(val) <span class="comment">// 当父级传递过来的数据发生变化，重新渲染图表</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initChart</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initChart</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">chart</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chart</span>.<span class="title function_">dispose</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chart</span> = <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">initChart</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">      newPromise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">chart</span> = <span class="variable language_">this</span>.<span class="property">$echarts</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="string">&#x27;macarons&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setOptions</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setOptions</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      data = <span class="variable language_">this</span>.<span class="property">chartData</span></span><br><span class="line">      <span class="keyword">const</span> showed = data.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> type = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        type = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = <span class="string">&#x27;pie&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">chart</span>.<span class="title function_">setOption</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: &#123; <span class="attr">show</span>: showed, <span class="attr">text</span>: <span class="string">&#x27;暂无数据&#x27;</span>, <span class="attr">x</span>: <span class="string">&#x27;center&#x27;</span>, <span class="attr">y</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">          <span class="attr">textStyle</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;#909399&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>, <span class="attr">fontSize</span>: <span class="number">14</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">tooltip</span>: &#123; <span class="attr">backgroundColor</span>: <span class="string">&#x27;#fff&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;item&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">legend</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;scroll&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;rect&#x27;</span>, <span class="attr">itemWidth</span>: <span class="number">12</span>, <span class="attr">itemHeight</span>: <span class="number">10</span>, <span class="attr">orient</span>: <span class="string">&#x27;horizontal&#x27;</span>, <span class="attr">bottom</span>: <span class="string">&#x27;0&#x27;</span>, <span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">series</span>: [&#123; <span class="comment">// this.name 是父级传递过来的数据，在 props 中</span></span><br><span class="line">          <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>, <span class="attr">type</span>: type, <span class="attr">radius</span>: [<span class="string">&#x27;40%&#x27;</span>, <span class="string">&#x27;70%&#x27;</span>], <span class="attr">avoidLabelOverlap</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">itemStyle</span>: &#123; <span class="attr">borderRadius</span>: <span class="number">10</span>, <span class="attr">borderColor</span>: <span class="string">&#x27;#fff&#x27;</span>, <span class="attr">borderWidth</span>: <span class="number">2</span> &#125;,</span><br><span class="line">          <span class="attr">label</span>: &#123; <span class="attr">show</span>: <span class="literal">false</span>, <span class="attr">position</span>: <span class="string">&#x27;center&#x27;</span> &#125;,</span><br><span class="line">          <span class="attr">emphasis</span>: &#123; <span class="attr">label</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;20&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">labelLine</span>: &#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">          <span class="attr">data</span>: data</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="无数据渲染"><a href="#无数据渲染" class="headerlink" title="无数据渲染"></a>无数据渲染</h5><p>当图表没有数据时渲染可能会出现一个灰色的圈<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/Echarts/null.png?raw=true" alt="null" loading="lazy"><br>我去看了 echarts 官网 api，发现当 series 中的 data 为空时会出现一个灰色的圈，<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/Echarts/example.png?raw=true" alt="example" loading="lazy"><br>但当 type 为 ‘’ 时，灰色的圈就不见了<br><img src="https://cdn.jsdelivr.net/gh/Melanie618/CDN@v1.1/images/Echarts/type=null.png?raw=true" alt="type=null" loading="lazy"></p>
<p>但实际上使用时还是会有问题，所以我单独写了一个 div 用来放 暂无数据 这个字段<br>通过 eventBus 来传递数据给父级元素，当数据为空时直接展示 暂无数据<br>这个是在当前页获取数据时用的，如果是父级传参过来的话，直接在父级获取参数的地方做判断就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在获取参数的接口做判断，当 data 没有数据就给父级传参</span></span><br><span class="line"><span class="title function_">getChartData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">getChartData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = response.<span class="property">response</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">length</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$EventBus</span>.$emit(<span class="string">&#x27;aMsg&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关于 eventBus 可以去参考我的 vue组件通信，如果你没找到这篇那就说我在重新整理文章，毕竟最开始对一些 api 没有过多了解，现在有了一些深入了解，和之前的想法也不一样了</p>
]]></content>
      <categories>
        <category>Echarts</category>
        <category>饼图使用</category>
      </categories>
      <tags>
        <tag>不以by小经验</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
</search>
